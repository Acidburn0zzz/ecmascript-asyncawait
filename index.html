<!doctype html>
<head><meta charset="utf8">
<link rel="stylesheet" href="https://bterlson.github.com/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<style>
  emu-production.inline emu-mods {
    display: none;
  }
</style>

<title>Async Functions</title>
</head><body><h1>Async Functions</h1>
<div><h2>Table of Contents</h2><ol class="toc"><li><a href="#intro"><span class="secnum"></span> Introduction</a><ol class="toc"><li><a href="#status"><span class="secnum"></span> Status of this proposal</a></li><li><a href="#examples"><span class="secnum"></span> Examples</a></li></ol></li><li><a href="#async-function-definitions"><span class="secnum">1</span> Async Function Definitions</a><ol class="toc"><li><a href="#async-function-definition-static-semantics-early-errors"><span class="secnum">1.1</span> Static Semantics: Early Errors</a></li><li><a href="#async-function-definition-static-semantics-LexicallyDeclaredNames"><span class="secnum">1.2</span> Static Semantics: LexicallyDeclaredNames</a></li><li><a href="#async-function-definition-static-semantics-CoveredAsyncArrowHead"><span class="secnum">1.3</span> Static Semantics: CoveredAsyncArrowHead</a></li><li><a href="#async-function-definition-static-semantics-BoundNames"><span class="secnum">1.4</span> Static Semantics: BoundNames</a></li><li><a href="#async-function-definition-static-semantics-ComputedPropertyContains"><span class="secnum">1.5</span> Static Semantics: ComputedPropertyContains</a></li><li><a href="#async-function-definition-static-semantics-Contains"><span class="secnum">1.6</span> Static Semantics: Contains</a></li><li><a href="#async-function-definition-static-semantics-ContainsExpression"><span class="secnum">1.7</span> Static Semantics: ContainsExpression</a></li><li><a href="#async-function-definition-static-semantics-HasInitializer"><span class="secnum">1.8</span> Static Semantics: HasInitializer</a></li><li><a href="#async-function-definition-static-semantics-ExpectedArgumentCount"><span class="secnum">1.9</span> Static Semantics: ExpectedArgumentCount</a></li><li><a href="#async-function-definition-static-semantics-HasComputedPropertyKey"><span class="secnum">1.10</span> Static Semantics: HasComputedPropertyKey</a></li><li><a href="#async-function-definition-static-semantics-HasDirectSuper"><span class="secnum">1.11</span> Static Semantics: HasDirectSuper</a></li><li><a href="#async-function-definition-static-semantics-HasName"><span class="secnum">1.12</span> Static Semantics: HasName</a></li><li><a href="#async-function-definition-static-semantics-IsConstantDeclaration"><span class="secnum">1.13</span> Static Semantics: IsConstantDeclaration</a></li><li><a href="#async-function-definition-static-semantics-IsFunctionDefinition"><span class="secnum">1.14</span> Static Semantics: IsFunctionDefinition</a></li><li><a href="#async-function-definition-static-semantics-PropName"><span class="secnum">1.15</span> Static Semantics: PropName</a></li><li><a href="#async-function-definitions-InstantiateFunctionObject"><span class="secnum">1.16</span> Runtime Semantics: InstantiateFunctionObject</a></li><li><a href="#async-function-definitions-EvaluateBody"><span class="secnum">1.17</span> Runtime Semantics: EvaluateBody</a></li><li><a href="#async-function-definitions-AsyncFunctionStart"><span class="secnum">1.18</span> Runtime Semantics: AsyncFunctionStart</a></li><li><a href="#async-function-definitions-awaited-resolved"><span class="secnum">1.19</span> AsyncFunction Awaited Resolved</a></li><li><a href="#async-function-definitions-awaited-rejected"><span class="secnum">1.20</span> AsyncFunction Awaited Rejected</a></li><li><a href="#async-function-definitions-runtime-semantics-evaluation"><span class="secnum">1.21</span> Runtime Semantics: Evaluation</a></li></ol></li><li><a href="#async-function-objects"><span class="secnum">2</span> Async Function Objects</a><ol class="toc"><li><a href="#async-function-constructor"><span class="secnum">2.1</span> The Async Function Constructor</a><ol class="toc"><li><a href="#async-function-constructor-arguments"><span class="secnum">2.1.1</span> AsyncFunction(<var>p1</var>, <var>p2</var>, ..., <var>pn</var>, _body)</a></li></ol></li><li><a href="#async-function-constructor-properties"><span class="secnum">2.2</span> Properties of the AsyncFunction constructor</a><ol class="toc"><li><a href="#async-function-constructor-length"><span class="secnum">2.2.1</span> AsyncFunction.length</a></li><li><a href="#async-function-constructor-prototype"><span class="secnum">2.2.2</span> AsyncFunction.prototype</a></li></ol></li><li><a href="#async-function-prototype-properties"><span class="secnum">2.3</span> Properties of the AsyncFunction Prototype Object</a><ol class="toc"><li><a href="#async-function-prototype-properties-constructor"><span class="secnum">2.3.1</span> AsyncFunction.prototype.constructor</a></li><li><a href="#async-function-prototype-properties-toStringTag"><span class="secnum">2.3.2</span> AsyncFunction.prototype[@@toStringTag]</a></li></ol></li><li><a href="#async-function-instances"><span class="secnum">2.4</span> AsyncFunction Instances</a><ol class="toc"><li><a href="#async-function-instances-length"><span class="secnum">2.4.1</span> length</a></li><li><a href="#async-function-instances-name"><span class="secnum">2.4.2</span> name</a></li></ol></li></ol></li><li><a href="#abstract-ops"><span class="secnum">3</span> Abstract Operations</a><ol class="toc"><li><a href="#abstract-ops"><span class="secnum">3.1</span> AsyncFunctionCreate(kind, ParameterList, Body, Scope, Strict)</a></li></ol></li><li><a href="#modified-productions"><span class="secnum">4</span> Modifications to existing productions</a><ol class="toc"><li><a href="#HoistableDeclaration"><span class="secnum">4.1</span> <emu-nt>HoistableDeclaration</emu-nt></a></li><li><a href="#PrimaryExpression"><span class="secnum">4.2</span> <emu-nt>PrimaryExpression</emu-nt></a></li><li><a href="#CallExpression"><span class="secnum">4.3</span> <emu-nt>CallExpression</emu-nt></a></li><li><a href="#UnaryExpression"><span class="secnum">4.4</span> <emu-nt>UnaryExpression</emu-nt></a></li><li><a href="#MethodDefinition"><span class="secnum">4.5</span> <emu-nt>MethodDefinition</emu-nt></a></li><li><a href="#AssignmentExpression"><span class="secnum">4.6</span> <emu-nt>AssignmentExpression</emu-nt></a></li><li><a href="#ConciseBody"><span class="secnum">4.7</span> <emu-nt>ConciseBody</emu-nt></a></li><li><a href="#ExpressionStatement"><span class="secnum">4.8</span> <emu-nt>ExpressionStatement</emu-nt></a></li></ol></li><li><a href="#todo"><span class="secnum">A</span> Todo &amp; Known Issues</a></li><li><a href="#desugaring"><span class="secnum">B</span> Informative Desugaring</a></li></ol></div><emu-intro id="intro">
  <h1><span class="secnum"></span>Introduction</h1>
  <p>The introduction of Promises and Generators in ECMAScript presents an opportunity to dramatically improve the language-level model for writing asynchronous code in ECMAScript.</p>

  <p>A similar proposal was made with <a href="http://wiki.ecmascript.org/doku.php?id=strawman:deferred_functions">Defered Functions</a> during ES6 discussions. The proposal here supports the same use cases, using similar or the same syntax, but directly building upon generators and promises instead of defining custom mechanisms.</p>

  <p>Development of this proposal is happening at <a href="https://github.com/tc39/ecmascript-asyncawait">https://github.com/tc39/ecmascript-asyncawait</a>. Please file issues there. Non-trivial contributions are limited to TC39 members but pull requests for minor issues are welcome and encouraged!</p>

  <emu-intro id="status">
    <h1><span class="secnum"></span>Status of this proposal</h1>

    <p>This proposal was accepted into stage 1 ("Proposal") of the ECMASCript 7 <a href="https://docs.google.com/document/d/1QbEE0BsO4lvl7NFTn5WXWeiEIBfaVUF7Dk0hpPpPDzU">spec process</a> in January 2014 (<a href="http://esdiscuss.org/notes/2014-01-30#async-await">discussion</a>).</p>
  </emu-intro>
  <emu-intro id="examples">
    <h1><span class="secnum"></span>Examples</h1>

    <p>Take the following example, first written using Promises. This code chains a set of animations on an element, stopping when there is an exception in an animation, and returning the value produced by the final succesfully executed animation.</p>

    <pre><code lang="javascript" class="hljs javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsPromise</span>(<span class="hljs-params">elem, animations</span>) </span>{
        <span class="hljs-keyword">var</span> ret = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> p = currentPromise;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> anim <span class="hljs-keyword">of</span> animations) {
            p = p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
                ret = val;
                <span class="hljs-keyword">return</span> anim(elem);
            })
        }
        <span class="hljs-keyword">return</span> p.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
            <span class="hljs-comment">/* ignore and keep going */</span>
        }).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> ret;
        });
    }
    </code></pre>

    <p>Already with promises, the code is much improved from a straight callback style, where this sort of looping and exception handling is challenging.</p>
    

    <a href="http://taskjs.org">Task.js</a> and similar libraries offer a way to use generators to further simplify the code maintaining the same meaning:

    <pre><code class="javascript hljs">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsGenerator</span>(<span class="hljs-params">elem, animations</span>) </span>{
        <span class="hljs-keyword">return</span> spawn(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> ret = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> anim <span class="hljs-keyword">of</span> animations) {
                    ret = <span class="hljs-keyword">yield</span> anim(elem);
                }
            } <span class="hljs-keyword">catch</span>(e) { <span class="hljs-comment">/* ignore and keep going */</span> }
            <span class="hljs-keyword">return</span> ret;
        });
    }
    </code></pre>

    <p>This is a marked improvement. All of the promise boilerplate above and beyond the semantic content of the code is removed, and the body of the inner function represents user intent. However, there is an outer layer of boilerplate to wrap the code in an additional generator function and pass it to a library to convert to a promise. This layer needs to be repeated in every function that uses this mechanism to produce a promise. This is so common in typical async Javascript code, that there is value in removing the need for the remaining boilerplate.</p>

    <p>With async functions, all the remaining boiler plate is removed, leaving only the semantically meaningful code in the program text:</p>

    <pre><code class="javascript hljs">
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsAsync</span>(<span class="hljs-params">elem, animations</span>) </span>{
        <span class="hljs-keyword">var</span> ret = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> anim <span class="hljs-keyword">of</span> animations) {
                ret = <span class="hljs-keyword">await</span> anim(elem);
            }
        } <span class="hljs-keyword">catch</span>(e) { <span class="hljs-comment">/* ignore and keep going */</span> }
        <span class="hljs-keyword">return</span> ret;
    }
    </code></pre>

    <p>This is morally similar to generators, which are a function form that produces a Generator object. This new async function form produces a Promise object.</p>
  </emu-intro>
</emu-intro>


<emu-clause id="async-function-definitions">
  <h1><span class="secnum">1</span>Async Function Definitions</h1>

  <h2>Syntax</h2>
<emu-grammar><emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
    <emu-rhs a="2" constraints="+Default"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
<emu-production name="AsyncFunctionExpression" type="lexical">
    <emu-nt>AsyncFunctionExpression</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
    <emu-rhs a="2"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt>BindingIdentifier</emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
<emu-production name="AsyncMethod" type="lexical">
    <emu-nt>AsyncMethod</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt>PropertyName</emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
<emu-production name="AsyncFunctionBody" type="lexical">
    <emu-nt>AsyncFunctionBody</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-nt params="Await">FunctionBody<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production>
<emu-production name="AwaitExpression" params="Yield" type="lexical">
    <emu-nt params="Yield">AwaitExpression<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>await</emu-t><emu-nt params="?Yield, Await">UnaryExpression<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production>
<emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[?Yield]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs>
    <emu-rhs a="2"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production>
<emu-production name="AsyncConciseBody" params="In" type="lexical">
    <emu-nt params="In">AsyncConciseBody<emu-mods><emu-params>[In]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-gann>[lookahead ≠ <emu-t>{</emu-t>]</emu-gann><emu-nt params="?In">AssignmentExpression<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs>
    <emu-rhs a="2"><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
<emu-production name="AsyncArrowBindingIdentifier" params="Yield">
    <emu-nt params="Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">BindingIdentifier<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production>
<emu-production name="CoverCallExpressionAndAsyncArrowHead" params="Yield, Await" type="lexical">
    <emu-nt params="Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods><emu-params>[Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, ?Await">MemberExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-nt params="?Yield, ?Await">Arguments<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production></emu-grammar>

<emu-note><span class="note">Note</span><code>yield</code> is <emu-nt>Identifier</emu-nt> or <emu-nt>YieldExpression</emu-nt> in <emu-nt>FunctionParameters</emu-nt> of <emu-nt>AsyncFunctionDeclaration</emu-nt> and <emu-nt>AsyncFunctionExpression</emu-nt> and <emu-nt>ArrowParameters</emu-nt> of <emu-nt>AsyncArrowFunction</emu-nt> depending on context. <code>await</code> is always parsed as an <emu-nt>AwaitExpression</emu-nt> but is a Syntax Error via static semantics. Yield is always allowed as an identifier of an <emu-nt>AsyncFunctionExpression</emu-nt>.</emu-note>


<h3>Supplemental Syntax</h3>
<p>When processing the production <emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="1" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[?Yield]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production> the interpretation of <emu-nt>CoverCallExpressionAndAsyncArrowHead</emu-nt> is refined using the following gramar:</p>

<emu-grammar><emu-production name="AsyncArrowHead" params="Yield" type="lexical">
    <emu-nt params="Yield">AsyncArrowHead<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-nt>async</emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production></emu-grammar>

  <emu-clause id="async-function-definition-static-semantics-early-errors">
  <h1><span class="secnum">1.1</span>Static Semantics: Early Errors</h1>
  <p>
    <emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="1" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
    <emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="2" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2" constraints="+Default"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
    <emu-production name="AsyncFunctionExpression" type="lexical" a="1" class="inline">
    <emu-nt>AsyncFunctionExpression</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production>
  </p>
  <ul>
    <li>It is a Syntax Error if <emu-nt>FormalParameters</emu-nt> Contains <emu-nt>AwaitExpression</emu-nt> is <emu-val>true</emu-val>.
    </li><li>If the source code matching this production is strict code, the Early Error rules for <emu-nt>StrictFormalParameters</emu-nt> : <emu-nt>FormalParameters</emu-nt> are applied.
    </li><li>If the source code matching this production is strict code, it is a Syntax Error if <emu-nt>BindingIdentifier</emu-nt> is the <emu-nt>IdentifierName</emu-nt> <code>eval</code> or the <emu-nt>IdentifierName</emu-nt> <code>arguments</code>.
    </li><li>It is a Syntax Error if any element of the BoundNames of <emu-nt>FormalParameters</emu-nt> also occurs in the LexicallyDeclaredNames of <emu-nt>AsyncFunctionBody</emu-nt>.
    </li><li>It is a Syntax Error if <emu-nt>FormalParameters</emu-nt> contains <emu-nt>SuperProperty</emu-nt> is <emu-val>true</emu-val>.
    </li><li>It is a Syntax Error if <emu-nt>AsyncFunctionBody</emu-nt> contains <emu-nt>SuperProperty</emu-nt> is <emu-val>true</emu-val>.
  </li></ul>
  <p><emu-production name="AsyncMethod" type="lexical" a="1" class="inline">
    <emu-nt>AsyncMethod</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt>PropertyName</emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
  <ul>
    <li>It is a Syntax Error if HasDirectSuper of <emu-nt>AsyncMethod</emu-nt> is <emu-val>true</emu-val>.
    </li><li>It is a Syntax Error if <emu-nt>StrictFormalParameters</emu-nt> Contains <emu-nt>AwaitExpression</emu-nt> is <emu-val>true</emu-val>.
    </li><li>It is a Syntax Error if any element of the BoundNames of <emu-nt>StrictFormalParameters</emu-nt> also occurs in the LexicallyDeclaredNames of <emu-nt>AsyncFunctionBody</emu-nt>
  </li></ul>
  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="1" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[?Yield]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <ul>
    <li>It is a Syntax Error if any element of the BoundNames of <emu-nt>AsyncArrowBindingIdentifier</emu-nt> also occurs in the LexicallyDeclaredNames of <emu-nt>AsyncConciseBody</emu-nt>.
  </li></ul>
  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="2" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <ul>
    <li>It is a SyntaxError if the lexical token sequence matched by <emu-nt>CoverCallExpressionAndAsyncArrowHead</emu-nt> cannot be parsed with no tokens left over using <emu-nt>AsyncArrowHead</emu-nt> as the goal symbol.</li>
    <li>All Early Error rules for <emu-nt>AsyncArrowHead</emu-nt> and its derived productions apply to CoveredAsyncArrowHead of <emu-nt>CoverCallExpressionAndAsyncArrowHead</emu-nt>.</li>
  </ul>
  <p><emu-production name="AsyncArrowHead" params="Yield" type="lexical" class="inline">
    <emu-nt params="Yield">AsyncArrowHead<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-nt>async</emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production></p>
  <ul>
    <li>It is a SyntaxError if <emu-nt>ArrowFormalParameters</emu-nt> Contains <emu-nt>YieldExpression</emu-nt> is true.
    </li><li>It is a SyntaxError if <emu-nt>ArrowFormalParameters</emu-nt> Contains <emu-nt>AwaitExpression</emu-nt> is true.
    </li><li>It is a Syntax Error if any element of the BoundNames of <emu-nt>ArrowFormalParameters</emu-nt> also occurs in the LexicallyDeclaredNames of <emu-nt>AsyncConciseBody</emu-nt>.
  </li></ul>
</emu-clause>

<emu-clause id="async-function-definition-static-semantics-LexicallyDeclaredNames">
  <h1><span class="secnum">1.2</span>Static Semantics: LexicallyDeclaredNames</h1>
  <p><emu-production name="AsyncConciseBody" params="In" type="lexical" a="1">
    <emu-nt params="In">AsyncConciseBody<emu-mods><emu-params>[In]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-gann>[lookahead ≠ <emu-t>{</emu-t>]</emu-gann><emu-nt params="?In">AssignmentExpression<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return an empty List.</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definition-static-semantics-CoveredAsyncArrowHead">
  <h1><span class="secnum">1.3</span>Static Semantics: CoveredAsyncArrowHead</h1>
  <p><emu-production name="CoverCallExpressionAndAsyncArrowHead" params="Yield, Await" type="lexical" class="inline">
    <emu-nt params="Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods><emu-params>[Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, ?Await">MemberExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-nt params="?Yield, ?Await">Arguments<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production></p>
  <ul>
    <li>Return the result of parsing the lexical token stream matched by <emu-nt>CoverCallExpressionAndAsyncArrowHead</emu-nt><sub>[Yield, Await]</sub> using either <emu-nt>AsyncArrowHead</emu-nt>, <emu-nt>AsyncArrowHead</emu-nt><sub>[Yield]</sub>, <emu-nt>AsyncArrowHead</emu-nt><sub>[Await]</sub>, or <emu-nt>AsyncArrowHead</emu-nt><sub>[Yield, Await]</sub> as the goal symbol depending upon whether the <sub>[Yield]</sub> and <sub>[Await]</sub> grammar parameters were present when <emu-nt>CoverCallExpressionAndAsyncArrowHead</emu-nt> was matched.</li>
  </ul>
</emu-clause>

<emu-clause id="async-function-definition-static-semantics-BoundNames">
  <h1><span class="secnum">1.4</span>Static Semantics: BoundNames</h1>
  <p><emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="1" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return the BoundNames of <emu-nt>BindingIdentifier</emu-nt>.</li>
</ol></emu-alg>
  <p><emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="2" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2" constraints="+Default"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return «<code>"<emu-val>default</emu-val>"</code>».</li>
</ol></emu-alg>
  <emu-note><span class="note">Note</span>"<emu-val>default</emu-val>" is used within this specification as a synthetic name for hoistable anonymous functions that are defined using export declarations.</emu-note>
  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="1" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[?Yield]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return the BoundNames of <emu-nt>AsyncArrowBindingIdentifier</emu-nt>.</li>
</ol></emu-alg>
  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="2" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Let head be CoveredAsyncArrowHead of <emu-nt>CoverCallExpressionAndAsyncArrowHead</emu-nt>.</li>
  <li>Return the BoundNames of <var>head</var>.</li>
</ol></emu-alg>
  <p><emu-production name="AsyncArrowBindingIdentifier" params="Yield" a="1" class="inline">
    <emu-nt params="Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">BindingIdentifier<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return the BoundNames of <emu-nt>BindingIdentifier</emu-nt>.</li>
</ol></emu-alg>
  <p><emu-production name="AsyncArrowHead" params="Yield" type="lexical" a="1" class="inline">
    <emu-nt params="Yield">AsyncArrowHead<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-nt>async</emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return the BoundNames of <emu-nt>ArrowFormalParameters</emu-nt>.</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definition-static-semantics-ComputedPropertyContains">
  <h1><span class="secnum">1.5</span>Static Semantics: ComputedPropertyContains</h1>
  <p>With parameter <var>symbol</var>.</p>
  <p><emu-production name="AsyncMethod" type="lexical" class="inline">
    <emu-nt>AsyncMethod</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt>PropertyName</emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production></p>
  <emu-alg><ol>
  <li>Return the result of ComputedPropertyContains for <emu-nt>PropertyName</emu-nt> with argument <var>symbol</var>.</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definition-static-semantics-Contains">
  <h1><span class="secnum">1.6</span>Static Semantics: Contains</h1>
  <p>With parameter <var>symbol</var>.</p>
  <p>
    <emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="1" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
    <emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="2" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2" constraints="+Default"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
    <emu-production name="AsyncFunctionExpression" type="lexical" class="inline">
    <emu-nt>AsyncFunctionExpression</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
    <emu-rhs a="2"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt>BindingIdentifier</emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
  </p>
  <emu-alg><ol>
  <li>Return <emu-val>false</emu-val>.</li>
</ol></emu-alg>
  <emu-note><span class="note">Note 1</span>Could probably check if <var>symbol</var> is one of these declarations or expressions, but this is not done in current spec and may not be necessary. See also: <a href="https://bugs.ecmascript.org/show_bug.cgi?id=4383">https://bugs.ecmascript.org/show_bug.cgi?id=4383</a>.</emu-note>
  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="1" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[?Yield]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>If <var>symbol</var> is not one of <emu-nt>NewTarget</emu-nt>, <emu-nt>SuperProperty</emu-nt>, <emu-nt>SuperCall</emu-nt>,
    <emu-t>super</emu-t>, or
    <emu-t>this</emu-t>, return <emu-val>false</emu-val>.</li>
  <li>Return <emu-nt>AsyncConciseBody</emu-nt> contains <var>symbol</var>.</li>
</ol></emu-alg>
  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="2" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>If <var>symbol</var> is not one of <emu-nt>NewTarget</emu-nt>, <emu-nt>SuperProperty</emu-nt>, <emu-nt>SuperCall</emu-nt>,
    <emu-t>super</emu-t>, or
    <emu-t>this</emu-t>, return <emu-val>false</emu-val>.</li>
  <li>Let <var>head</var> be CoveredAsyncFunctionHead of <emu-nt>CoverCallExpressionAndAsyncArrowHead</emu-nt>.</li>
  <li>If <var>head</var> Contains <var>symbol</var> is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li>
  <li>return <emu-nt>AsyncConciseBody</emu-nt> Contains <var>symbol</var>.</li>
</ol></emu-alg>
  <emu-note><span class="note">Note 2</span>Normally, Contains does not look inside most function forms. However, Contains is used to detect <code>new.target</code>, <code>this</code>, and <code>super</code> usage within an AsyncArrowFunction.</emu-note>
  <p><emu-production name="AsyncArrowHead" params="Yield" type="lexical" class="inline">
    <emu-nt params="Yield">AsyncArrowHead<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-nt>async</emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production></p>
  <emu-alg><ol>
  <li>Return <emu-nt>ArrowFormalParameters</emu-nt> Contains <var>symbol</var>.</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definition-static-semantics-ContainsExpression">
  <h1><span class="secnum">1.7</span>Static Semantics: ContainsExpression</h1>
  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="1" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[?Yield]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return <emu-val>false</emu-val>.</li>
</ol></emu-alg>

  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="2" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Let <var>head</var> be CoveredAsyncFunctionHead of <emu-nt>CoverCallExpressionAndAsyncArrowHead</emu-nt>.</li>
  <li>Return ContainsExpression of <var>head</var>.</li>
</ol></emu-alg>

  <p><emu-production name="AsyncArrowHead" params="Yield" type="lexical" class="inline">
    <emu-nt params="Yield">AsyncArrowHead<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-nt>async</emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs>
</emu-production></p>
  <emu-alg><ol>
  <li>Return ContainsExpression of <emu-nt>ArrowFormalParameters</emu-nt>.</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definition-static-semantics-HasInitializer">
  <h1><span class="secnum">1.8</span>Static Semantics: HasInitializer</h1>
  <p><emu-production name="AsyncArrowBindingIdentifier" params="Yield" class="inline" a="1">
    <emu-nt params="Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">BindingIdentifier<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return <emu-val>false</emu-val>.</li>
</ol></emu-alg>
  <p><emu-production name="AsyncArrowHead" params="Yield" type="lexical" class="inline" a="1">
    <emu-nt params="Yield">AsyncArrowHead<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-nt>async</emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return HasInitializer of <emu-nt>ArrowFormalParameters</emu-nt>.</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definition-static-semantics-ExpectedArgumentCount">
  <h1><span class="secnum">1.9</span>Static Semantics: ExpectedArgumentCount</h1>
  <p><emu-production name="AsyncArrowBindingIdentifier" params="Yield" class="inline" a="1">
    <emu-nt params="Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">BindingIdentifier<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return <emu-val>1</emu-val>.</li>
</ol></emu-alg>
  <p><emu-production name="AsyncArrowHead" params="Yield" type="lexical" class="inline" a="1">
    <emu-nt params="Yield">AsyncArrowHead<emu-mods><emu-params>[Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-nt>async</emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return HasInitializer of <emu-nt>ArrowFormalParameters</emu-nt>.</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definition-static-semantics-HasComputedPropertyKey">
  <h1><span class="secnum">1.10</span>Static Semantics: HasComputedPropertyKey</h1>
  <p><emu-production name="AsyncMethod" type="lexical" class="inline">
    <emu-nt>AsyncMethod</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt>PropertyName</emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production></p>
  <emu-alg><ol>
  <li>Return IsComputedPropertyKey of <var>PropertyName</var>.</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definition-static-semantics-HasDirectSuper">
  <h1><span class="secnum">1.11</span>Static Semantics: HasDirectSuper</h1>
  <p>
    <emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="1" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
    <emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="2" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2" constraints="+Default"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
    <emu-production name="AsyncFunctionExpression" type="lexical" class="inline">
    <emu-nt>AsyncFunctionExpression</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
    <emu-rhs a="2"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt>BindingIdentifier</emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
  </p>
  <emu-alg><ol>
  <li>If <emu-nt>FormalParameters</emu-nt> Contains <emu-nt>SuperCall</emu-nt> is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li>
  <li>Return <emu-nt>AsyncFunctionBody</emu-nt> Contains <emu-nt>SuperCall</emu-nt>.</li>
</ol></emu-alg>
  <p>
    <emu-production name="AsyncMethod" type="lexical" class="inline">
    <emu-nt>AsyncMethod</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt>PropertyName</emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production>
  </p>
  <emu-alg><ol>
  <li>If <emu-nt>StrictFormalParameters</emu-nt> Contains <emu-nt>SuperCall</emu-nt> is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li>
  <li>Return <emu-nt>AsyncFunctionBody</emu-nt> Contains <emu-nt>SuperCall</emu-nt>.</li>
</ol></emu-alg>
</emu-clause>
<emu-clause id="async-function-definition-static-semantics-HasName">
  <h1><span class="secnum">1.12</span>Static Semantics: HasName</h1>
  <p><emu-production name="AsyncFunctionExpression" type="lexical" a="1" class="inline">
    <emu-nt>AsyncFunctionExpression</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return <emu-val>false</emu-val>.</li>
</ol></emu-alg>
  <p><emu-production name="AsyncFunctionExpression" type="lexical" a="2" class="inline">
    <emu-nt>AsyncFunctionExpression</emu-nt><emu-geq>::</emu-geq><emu-rhs a="2"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt>BindingIdentifier</emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return <emu-val>true</emu-val>.</li>
</ol></emu-alg>
  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="1" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[?Yield]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="2" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return <emu-val>false</emu-val>.</li>
</ol></emu-alg>
</emu-clause> 
<emu-clause id="async-function-definition-static-semantics-IsConstantDeclaration">
  <h1><span class="secnum">1.13</span>Static Semantics: IsConstantDeclaration</h1>
  <p>
    <emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="1" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
    <emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="2" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2" constraints="+Default"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production>
  </p>
  <emu-alg><ol>
  <li>Return <emu-val>true</emu-val>.</li>
</ol></emu-alg>
</emu-clause>
<emu-clause id="async-function-definition-static-semantics-IsFunctionDefinition">
  <h1><span class="secnum">1.14</span>Static Semantics: IsFunctionDefinition</h1>
  <p>
    <emu-production name="AsyncFunctionExpression" type="lexical" class="inline" a="1">
    <emu-nt>AsyncFunctionExpression</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
    <emu-production name="AsyncFunctionExpression" type="lexical" class="inline" a="2">
    <emu-nt>AsyncFunctionExpression</emu-nt><emu-geq>::</emu-geq><emu-rhs a="2"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt>BindingIdentifier</emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production>
  </p>
  <emu-alg><ol>
  <li>Return <emu-val>true</emu-val>.</li>
</ol></emu-alg>
</emu-clause>
<emu-clause id="async-function-definition-static-semantics-PropName">
  <h1><span class="secnum">1.15</span>Static Semantics: PropName</h1>
  <p>
    <emu-production name="AsyncMethod" type="lexical" class="inline">
    <emu-nt>AsyncMethod</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt>PropertyName</emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
</emu-production><br>
  </p>
  <emu-alg><ol>
  <li>Return PropName of <emu-nt>PropertyName</emu-nt>.</li>
</ol></emu-alg>
</emu-clause>

  <emu-clause id="async-function-definitions-InstantiateFunctionObject">
  <h1><span class="secnum">1.16</span>Runtime Semantics: InstantiateFunctionObject</h1>
  <p>With parameter <var>scope</var>.</p>
  <p><emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="1" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>If the function code for <emu-nt>AsyncFunctionDeclaration</emu-nt> is strict mode code, let <var>strict</var> be <emu-val>true</emu-val>. Otherwise, let <var>strict</var> be <emu-val>false</emu-val>.</li>
  <li>Let <var>name</var> be StringValue of <emu-nt>BindingIdentifier</emu-nt></li>
  <li>Let <var>F</var> be <a href="#abstract-ops">AsyncFunctionCreate</a>(<emu-const>Normal</emu-const>, <emu-nt>FormalParameters</emu-nt>, <emu-nt>AsyncFunctionBody</emu-nt>, <var>scope</var>, <var>strict</var>).</li>
  <li>Perform <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-setfunctionname">SetFunctionName</a>(<var>F</var>, <var>name</var>).</li>
</ol></emu-alg>
  <p><emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="2" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2" constraints="+Default"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>If the function code for <emu-nt>AsyncFunctionDeclaration</emu-nt> is strict mode code, let <var>strict</var> be <emu-val>true</emu-val>. Otherwise, let <var>strict</var> be <emu-val>false</emu-val>.</li>
  <li>Let <var>F</var> be <a href="#abstract-ops">AsyncFunctionCreate</a>(<emu-const>Normal</emu-const>, <emu-nt>FormalParameters</emu-nt>, <emu-nt>AsyncFunctionBody</emu-nt>, <var>scope</var>, <var>strict</var>).</li>
  <li>Perform <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-setfunctionname">SetFunctionName</a>(<var>F</var>, <code>"default"</code>).</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definitions-EvaluateBody">
  <h1><span class="secnum">1.17</span>Runtime Semantics: EvaluateBody</h1>
  <p>With parameter <var>functionObject</var>.</p>
  <p>
    <emu-production name="AsyncFunctionBody" type="lexical" a="1" class="inline">
    <emu-nt>AsyncFunctionBody</emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-nt params="Await">FunctionBody<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production><br>
    <emu-production name="AsyncConciseBody" params="In" type="lexical" a="1" class="inline">
    <emu-nt params="In">AsyncConciseBody<emu-mods><emu-params>[In]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-gann>[lookahead ≠ <emu-t>{</emu-t>]</emu-gann><emu-nt params="?In">AssignmentExpression<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production>
  </p>
  <emu-alg><ol>
  <li>Let <var>promiseCapability</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-newpromisecapability">NewPromiseCapability</a>(%Promise%).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>promiseCapability</var>).</li>
  <li>Let <var>G</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-objectcreate">ObjectCreate</a>(%GeneratorPrototype%, «[[GeneratorState]], [[GeneratorContext]]» ).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>G</var>).</li>
  <li>Perform <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorstart">GeneratorStart</a>(<var>G</var>, <var>FunctionBody</var>).</li>
  <li>Perform <a href="#async-function-definitions-AsyncFunctionStart">AsyncFunctionStart</a>(<var>G</var>, <var>promiseCapability</var>).</li>
  <li>Return Completion{[[type]]: return, [[value]]: <var>promiseCapability</var>.[[Promise]], [[target]]: empty}.</li>
</ol></emu-alg>

  <p><emu-production name="AsyncConciseBody" params="In" type="lexical" a="2" class="inline">
    <emu-nt params="In">AsyncConciseBody<emu-mods><emu-params>[In]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2"><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return the result of calling EvaluateBody of <emu-nt>AsyncFunctionBody</emu-nt>.</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definitions-AsyncFunctionStart" aoid="AsyncFunctionStart">
  <h1><span class="secnum">1.18</span>Runtime Semantics: AsyncFunctionStart</h1>
  <p>With parameters <var>generator</var>, <var>promiseCapability</var>, <var>operation</var>, and <var>value</var>. The parameters <var>operation</var> and <var>value</var> are optional.</p>
  <emu-note><span class="note">Note</span>This function does not return any important abrupt completions so in some cases they are ignored. In other cases, callers should ignore any abrupt completion values. Errors as a result of ticking forward the generator will be propagated as promise rejections. All other errors (such as those resulting from getting generator methods, calling Promise.resolve, or p.then) are ignored. It is possible that we can be statically assured that no errors will result from this algorithm.</emu-note>
  <emu-alg><ol>
  <li>If <var>operation</var> was not provided, let <var>operation</var> be <code>"next"</code>.</li>
  <li>If <var>value</var> was not provided, let <var>value</var> be <emu-val>undefined</emu-val>.</li>
  <li>let <var>operationFn</var> be the result of <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-get-o-p">Get</a>(<var>generator</var>, <var>operation</var>).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>operationFn</var>).</li>
  <li>let <var>result</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args">Call</a>(<var>next</var>, <var>generator</var>).</li>
  <li>If <var>result</var> is an abrupt completion, then
    <ol>
      <li>Perform <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args">Call</a>(<var>promiseCapability</var>.[[reject]], <emu-val>undefined</emu-val>, «<var>result</var>.value»)</li>
      <li>Return.</li>
    </ol>
  </li>
  <li>Assert: The async function has either awaited something or returned something.</li>
  <li>let <var>done</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-get-o-p">Get</a>(<var>result</var>, <code>"done"</code>).</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>done</var>).</li>
  <li>If <var>done</var> is <emu-val>true</emu-val>, then
    <ol>
      <li>Perform <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args">Call</a>(<var>promiseCapability</var>.[[resolve]], <emu-val>undefined</emu-val>, «<var>result</var>.value»).</li>
      <li>Return.</li>
    </ol>
  </li>
  <li>Assert: <var>done</var> is false, <var>result</var>.value is a value that has come out of the generator.</li>
  <li>let <var>awaitedPromise</var> be the result of <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args">Call</a>(%Promise%.resolve, %Promise%, «<var>result</var>.value»).</li>
  <li>let <var>promiseResolved</var> be a new built-in function object as defined in <a href="#async-function-definitions-awaited-resolved">AsyncFunction Awaited Resolved</a>.</li>
  <li>Set the [[Generator]] internal slot of <var>promiseResolved</var> to <var>generator</var>.</li>
  <li>Set the [[PromiseCapability]] internal slot of <var>promiseResolved</var> to <var>promiseCapability</var>.</li>
  <li>let <var>promiseRejected</var> be a new built-in function object as defined in <a href="#async-function-definitions-awaited-rejected">AsyncFunction Awaited Rejected</a>.</li>
  <li>Set the [[Generator]] internal slot of <var>promiseRejected</var> to <var>generator</var>.</li>
  <li>Set the [[PromiseCapability]] internal slot of <var>promiseRejected</var> to <var>promiseCapability</var>.</li>
  <li><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-invoke">Invoke</a>(<var>awaitedPromise</var>, <code>"then"</code>, «<var>promiseResolved</var>, <var>promiseRejected</var>»).</li>
  <li>Return.</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definitions-awaited-resolved">
  <h1><span class="secnum">1.19</span>AsyncFunction Awaited Resolved</h1>
  <p>Function <var>F</var> is called with the parameter <var>value</var>.</p>
  <emu-alg><ol>
  <li>let <var>generator</var> be the value of <var>F</var>'s [[Generator]] internal slot.</li>
  <li>let <var>promiseCapability</var> be the value of <var>F</var>'s [[PromiseCapability]] internal slot.</li>
  <li>return the result of performing <a href="#async-function-definitions-AsyncFunctionStart">AsyncFunctionStart</a>(<var>generator</var>, <var>promiseCapability</var>, <code>"next"</code>, <var>value</var>).</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definitions-awaited-rejected">
  <h1><span class="secnum">1.20</span>AsyncFunction Awaited Rejected</h1>
  <p>Function <var>F</var> is called with the parameter <var>value</var>.</p>
  <emu-alg><ol>
  <li>let <var>generator</var> be the value of <var>F</var>'s [[Generator]] internal slot.</li>
  <li>let <var>promiseCapability</var> be the value of <var>F</var>'s [[PromiseCapability]] internal slot.</li>
  <li>return the result of performing <a href="#async-function-definitions-AsyncFunctionStart">AsyncFunctionStart</a>(<var>generator</var>, <var>promiseCapability</var>, <code>"throw"</code>, <var>value</var>).</li>
</ol></emu-alg>
</emu-clause>

<emu-clause id="async-function-definitions-runtime-semantics-evaluation">
  <h1><span class="secnum">1.21</span>Runtime Semantics: Evaluation</h1>
  <p><emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="1" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return.</li>
</ol></emu-alg>

  <p><emu-production name="AsyncFunctionDeclaration" params="Yield, Await, Default" type="lexical" a="2" class="inline">
    <emu-nt params="Yield, Await, Default">AsyncFunctionDeclaration<emu-mods><emu-params>[Yield, Await, Default]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2" constraints="+Default"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods><emu-params>[Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>Return.</li>
</ol></emu-alg>

  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="1" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-nt params="?Yield">AsyncArrowBindingIdentifier<emu-mods><emu-params>[?Yield]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>If the function code for this <emu-nt>AsyncArrowFunction</emu-nt> is strict mode code, let <var>strict</var> be true. Otherwise, let <var>strict</var> be false.</li>
  <li>Let <var>scope</var> be the LexicalEnvironment of the running execution context.</li>
  <li>Let <var>parameters</var> be <emu-nt>AsyncArrowBindingIdentifier</emu-nt>.</li>
  <li>Let <var>closure</var> be <a href="#abstract-ops">AsyncFunctionCreate</a>(<code>"Arrow"</code>, <var>parameters</var>, <emu-nt>ConciseBody</emu-nt>, <var>scope</var>, <var>strict</var>).</li>
  <li>Return <var>closure</var>.</li>
</ol></emu-alg>

  <p><emu-production name="AsyncArrowFunction" params="In, Yield" type="lexical" a="2" class="inline">
    <emu-nt params="In, Yield">AsyncArrowFunction<emu-mods><emu-params>[In, Yield]</emu-params></emu-mods></emu-nt><emu-geq>::</emu-geq><emu-rhs a="2"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator</emu-nt> here]</emu-gann><emu-t>=&gt;</emu-t><emu-nt params="?In">AsyncConciseBody<emu-mods><emu-params>[?In]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production></p>
  <emu-alg><ol>
  <li>If the function code for this <emu-nt>AsyncArrowFunction</emu-nt> is strict mode code, let <var>strict</var> be true. Otherwise, let <var>strict</var> be false.</li>
  <li>Let <var>scope</var> be the LexicalEnvironment of the running execution context.</li>
  <li>Let <var>head</var> be CoveredAsyncArrowHead of <emu-nt>CoverCallExpressionAndAsyncArrowHead</emu-nt>.</li>
  <li>Let <var>parameters</var> be the <emu-nt>ArrowFormalParameters</emu-nt> production matched by <var>head</var>.</li>
  <li>Let <var>closure</var> be <a href="#abstract-ops">AsyncFunctionCreate</a>(<code>"Arrow"</code>, <var>parameters</var>, <emu-nt>ConciseBody</emu-nt>, <var>scope</var>, <var>strict</var>).</li>
  <li>Return <var>closure</var>.</li>
</ol></emu-alg>
</emu-clause>

</emu-clause>
<emu-clause id="async-function-objects">
  <h1><span class="secnum">2</span>Async Function Objects</h1>
  <emu-clause id="async-function-constructor">
    <h1><span class="secnum">2.1</span>The Async Function Constructor</h1>

    <p>The <code>AsyncFunction</code> Constructor is the %AsyncFunction% intrinsic object and is a subclass of <code>Function</code>. When <code>AsyncFunction</code> is called as a function rather than as a constructor, it creates and initializes a new AsyncFunction object. Thus the function call <code>AsyncFunction(…)</code> is equivalent to the object creation expression <code>new AsyncFunction(…)</code> with the same arguments.</p>

    <p>The <code>AsyncFunction</code> constructor is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass constructors that intend to inherit the specified AsyncFunction behaviour must include a super call to the AsyncFunction constructor to create and initialize a subclass instances with the internal slots necessary for built-in async function behaviour.</p>

    <emu-clause id="async-function-constructor-arguments">
      <h1><span class="secnum">2.1.1</span>AsyncFunction(<var>p1</var>, <var>p2</var>, ..., <var>pn</var>, _body)</h1>

      <p>The last argument specifies the body (executable code) of an async function. Any preceding arguments specify formal parameters.

      </p><p>When the <code>AsyncFunction</code> function is called with some arguments <var>p1</var>, <var>p2</var>, ..., <var>pn</var>, <var>body</var> (where <var>n</var> migh tbe 0, that is, there are no <var>p</var> arguments, and where _body) might also not be provided), the following steps are taken:</p>

      <emu-alg><ol>
  <li>Let <var>C</var> be the active function object.</li>
  <li>Let <var>args</var> be the argumentsList that was passed to this function by [[Call]] or [[Construct]].</li>
  <li>Return CreateDynamicFunction(<var>C</var>, NewTarget, <code>"async"</code>, <var>args</var>)</li>
</ol></emu-alg>

      <emu-note><span class="note">Note</span>See note for 19.2.1.1</emu-note>
    </emu-clause>
  </emu-clause>
  <emu-clause id="async-function-constructor-properties">
    <h1><span class="secnum">2.2</span>Properties of the AsyncFunction constructor</h1>
    
    <p>The AsyncFunction constructor is a standard built-in function object that inherits from the <code>Function</code> constructor. The value of the [[Prototype]] internal slot of the AsyncFunction constructor is the intrinsic object %Function%.

    </p><p>The value of the [[Extensible]] internal slot of the AsyncFunction constructor is <emu-val>true</emu-val>

    </p><p>The value of the <emu-val>name</emu-val> property of the AsyncFunction is "AsyncFunction"

    </p><p>The AsyncFunction constructor has the following properties:</p>

    <emu-clause id="async-function-constructor-length">
      <h1><span class="secnum">2.2.1</span>AsyncFunction.length</h1>
      <p>This is a data property with a value of 1. This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>
    </emu-clause>

    <emu-clause id="async-function-constructor-prototype">
      <h1><span class="secnum">2.2.2</span>AsyncFunction.prototype</h1>
      <p>The intitial value of <code>AsyncFunction.prototype</code> is the intrinsic object %AsyncFunctionPrototype%.</p>

      <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }.</p>
    </emu-clause>
  </emu-clause>
  <emu-clause id="async-function-prototype-properties">
    <h1><span class="secnum">2.3</span>Properties of the AsyncFunction Prototype Object</h1>
    <p>The AsyncFunction prototype object is an ordinary object. In addition to being the value of the prototpe property of the %AsyncFunction% instrinsic, it is the %AsyncFunctionPrototype% intrinsic.</p>

    <p>The value of the [[Prototype]] internal slot of the AsyncFunction prototype object is the %FunctionPrototype% intrinsic object. The initial value of the [[Extensible]] internal slot of the AsyncFunction prototype object is <emu-val>true</emu-val>.</p>
    
    <p>The AsyncFunction prototype object does not have a prototype property.</p>
    <emu-note><span class="note">Note</span>Presumably this could be Promise.prototype but I'm not sure this has any value?</emu-note>


    <emu-clause id="async-function-prototype-properties-constructor">
      <h1><span class="secnum">2.3.1</span>AsyncFunction.prototype.constructor</h1>

      <p>The initial value of <code>AsyncFunction.prototype.constructor</code> is the intrinsic object %AsyncFunction%</p>

      <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>
    </emu-clause>

    <emu-clause id="async-function-prototype-properties-toStringTag">
      <h1><span class="secnum">2.3.2</span>AsyncFunction.prototype[@@toStringTag]</h1>

      <p>The initial value of the @@toStringTag property is the string value "AsyncFunction".</p>

      <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="async-function-instances">
    <h1><span class="secnum">2.4</span>AsyncFunction Instances</h1>

    <p>Every AsyncFunction instance is an ECMAScript function object and has the internal slots listed in Table 27. The value of the [[FunctionKind]] internal slot for all such instances is "generator".</p>

    <p>Each AsyncFunction instance has the following own properties:</p>

    <p>AsyncFunction instances do not have a prototype property as they are not constructable.</p>

    <emu-clause id="async-function-instances-length">
      <h1><span class="secnum">2.4.1</span>length</h1>
      <p>The value of the <emu-val>length</emu-val> property is an integer that indicates the typical number of arguments expected by the AsyncFunction. However, the language permits the function to be invoked with some other number of arguments. The behaviour of an AsyncFunction when invoked on a number of arguments other than the number specified by its length property depends on the function.</p>

      <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>
    </emu-clause>
    <emu-clause id="async-function-instances-name">
      <h1><span class="secnum">2.4.2</span>name</h1>

      <p>The specification for the <code>name</code> property of Function instances given in 19.2.4.2 also applies to Asyncfunction instances.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>
<emu-clause id="abstract-ops">
  <h1><span class="secnum">3</span>Abstract Operations</h1>
  <emu-clause id="abstract-ops" aoid="AsyncFunctionCreate">
    <h1><span class="secnum">3.1</span>AsyncFunctionCreate(kind, ParameterList, Body, Scope, Strict)</h1>
    <p>The abstract operation AsyncFunctionCreate requires the arguments: <var>kind</var> which is one of (Normal, Method, Arrow), a parameter list production specified by <emu-nt>ParameterList</emu-nt>, a body production specified by <emu-nt>Body</emu-nt>, a Lexical Environment specified by <var>Scope</var>, and a Boolean flag <var>Strict</var>. AsyncFunctionCreate performs the following steps:</p>
    <emu-alg><ol>
  <li>Let <var>functionPrototype</var> be the intrinsic object %AsyncFunctionPrototype%.</li>
  <li>Let <var>F</var> be <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-functionallocate">FunctionAllocate</a>(<var>functionPrototype</var>, <var>Strict</var>, <code>"non-constructor"</code>).</li>
  <li>Return <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-functioninitialize">FunctionInitialize</a>(<var>F</var>, <var>kind</var>, <emu-nt>ParameterList</emu-nt>, <emu-nt>Body</emu-nt>, <var>Scope</var>).</li>
</ol></emu-alg>
  </emu-clause>
</emu-clause>


<emu-clause id="modified-productions">
  <h1><span class="secnum">4</span>Modifications to existing productions</h1>
  <p>Unless otherwise defined in this section, every production that includes a <code>Yield</code> parameter is modified to include an <code>Await</code> parameter and any Non-terminal with a <code>?Yield</code> parameter is modified to include an <code>?Await</code> parameter.</p>

  <emu-clause id="HoistableDeclaration">
    <h1><span class="secnum">4.1</span><emu-nt>HoistableDeclaration</emu-nt></h1>
    <emu-production name="HoistableDeclaration" params="Yield, Default">
      <emu-nt params="Yield, Default">HoistableDeclaration<emu-mods><emu-params>[Yield, Default]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-nt params="?Yield, ?Default">FunctionDeclaration<emu-mods><emu-params>[?Yield, ?Default]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Default">GeneratorDeclaration<emu-mods><emu-params>[?Yield, ?Default]</emu-params></emu-mods></emu-nt></emu-rhs>
      <ins class="block"><emu-rhs><emu-nt params="?Yield, ?Default">AsyncFunctionDeclaration<emu-mods><emu-params>[?Yield, ?Default]</emu-params></emu-mods></emu-nt></emu-rhs></ins>
    </emu-production>
  </emu-clause>

  <emu-clause id="PrimaryExpression">
    <h1><span class="secnum">4.2</span><emu-nt>PrimaryExpression</emu-nt></h1>
    <emu-production name="PrimaryExpression" params="Yield, Await">
      <emu-nt params="Yield, Await">PrimaryExpression<emu-mods><emu-params>[Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-t>this</emu-t></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">IdentifierReference<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs> 
      <emu-rhs><emu-nt>Literal</emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">ArrayLiteral<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs> 
      <emu-rhs><emu-nt params="?Yield, ?Await">ObjectLiteral<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs> 
      <emu-rhs><emu-nt>FunctionExpression</emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">ClassExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Await">GeneratorExpression<emu-mods><emu-params>[?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <ins class="block"><emu-rhs><emu-nt params="?Yield">AsyncFunctionExpression<emu-mods><emu-params>[?Yield]</emu-params></emu-mods></emu-nt></emu-rhs></ins>
      <emu-rhs><emu-nt>RegularExpressionLiteral</emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield">TemplateLiteral<emu-mods><emu-params>[?Yield]</emu-params></emu-mods></emu-nt></emu-rhs>
    </emu-production>
  </emu-clause>

  <emu-clause id="CallExpression">
    <h1><span class="secnum">4.3</span><emu-nt>CallExpression</emu-nt></h1>
    <emu-production name="CallExpression" params="Yield, Await">
      <emu-nt params="Yield, Await">CallExpression<emu-mods><emu-params>[Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><ins class="block">
        <emu-rhs><emu-nt params="?Yield, ?Await">CoverCallExpressionAndAsyncArrowHead<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      </ins>
      <del class="block">
        <emu-rhs><emu-nt params="?Yield, ?Await">MemberExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-nt params="?Yield, ?Await">Arguments<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      </del>
      <emu-rhs><emu-nt params="?Yield, ?Await">SuperCall<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">CallExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-nt params="?Yield, ?Await">Arguments<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">CallExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>[</emu-t><emu-nt params="In, ?Yield, ?Await">Expression<emu-mods><emu-params>[In, ?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>]</emu-t></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">CallExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>.</emu-t><emu-nt>IdentifierName</emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">CallExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-nt params="?Yield, ?Await">TemplateLiteral<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
    </emu-production>
  </emu-clause>

  <emu-clause id="UnaryExpression">
    <h1><span class="secnum">4.4</span><emu-nt>UnaryExpression</emu-nt></h1>
    <emu-production name="UnaryExpression" params="Yield, Await">
      <emu-nt params="Yield, Await">UnaryExpression<emu-mods><emu-params>[Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-nt params="?Yield, ?Await">PostfixExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>delete</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>void</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>typeof</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>++</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>--</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>+</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>-</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>~</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <ins class="block"><emu-rhs constraints="+Await"><emu-constraints>[+Await]</emu-constraints><emu-nt params="?Yield">AwaitExpression<emu-mods><emu-params>[?Yield]</emu-params></emu-mods></emu-nt></emu-rhs></ins>
    </emu-production>

    <emu-note><span class="note">Note</span>Currently it is not possible for an <emu-nt>AwaitExpression</emu-nt> and a <emu-nt>YieldExpression</emu-nt> to be parsed together, so technically passing the <code>?Yield</code> parameter for <emu-production name="UnaryExpression" class="inline"><emu-nt>UnaryExpression</emu-nt><emu-geq>:</emu-geq><emu-rhs constraints="+Await"><emu-constraints>[+Await]</emu-constraints><emu-t>await</emu-t><emu-nt params="?Yield, Await">UnaryExpression<emu-mods><emu-params>[?Yield, Await]</emu-params></emu-mods></emu-nt></emu-rhs></emu-production> is unnecessary. It will probably be useful for AsyncGenerators however.</emu-note>
  </emu-clause>

  <emu-clause id="MethodDefinition">
    <h1><span class="secnum">4.5</span><emu-nt>MethodDefinition</emu-nt></h1>
    <emu-production name="MethodDefinition" params="Yield, Await">
      <emu-nt params="Yield, Await">MethodDefinition<emu-mods><emu-params>[Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-nt params="?Yield, ?Await">PropertyName<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt>StrictFormalParameters</emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>FunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">GeneratorMethod<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <ins class="block"><emu-rhs><emu-nt params="?Yield, ?Await">AsyncMethod<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs></ins>
      <emu-rhs><emu-t>get</emu-t><emu-nt params="?Yield, ?Await">PropertyName<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>FunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
      <emu-rhs><emu-t>set</emu-t><emu-nt params="?Yield, ?Await">PropertyName<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt>PropertySetParameterList</emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>FunctionBody</emu-nt><emu-t>}</emu-t></emu-rhs>
    </emu-production>
  </emu-clause>

  <emu-clause id="AssignmentExpression">
    <h1><span class="secnum">4.6</span><emu-nt>AssignmentExpression</emu-nt></h1>
    <emu-production name="AssignmentExpression" params="In, Yield, Await">
      <emu-nt params="In, Yield, Await">AssignmentExpression<emu-mods><emu-params>[In, Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-nt params="?In, ?Yield, ?Await">ConditionalExpression<emu-mods><emu-params>[?In, ?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs constraints="+Yield"><emu-constraints>[+Yield]</emu-constraints><emu-nt params="?In, ?Await">YieldExpression<emu-mods><emu-params>[?In, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?In, ?Yield, ?Await">ArrowFunction<emu-mods><emu-params>[?In, ?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <ins class="block"><emu-rhs><emu-nt params="?In, ?Yield">AsyncArrowFunction<emu-mods><emu-params>[?In, ?Yield]</emu-params></emu-mods></emu-nt></emu-rhs></ins>
      <emu-rhs><emu-nt params="?Yield, ?Await">LeftHandSideExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-t>=</emu-t><emu-nt params="?In, ?Yield, ?Await">AssignmentExpression<emu-mods><emu-params>[?In, ?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">LeftHandSideExpression<emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-nt>AssignmentOperator</emu-nt><emu-nt params="?In, ?Yield, ?Await">AssignmentExpression<emu-mods><emu-params>[?In, ?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
    </emu-production>
  </emu-clause>

  <emu-clause id="ConciseBody">
    <h1><span class="secnum">4.7</span><emu-nt>ConciseBody</emu-nt></h1>
    <emu-production name="ConciseBody" params="In, Await">
      <emu-nt params="In, Await">ConciseBody<emu-mods><emu-params>[In, Await]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-gann>[lookahead ≠ {]</emu-gann><emu-nt params="?In, ?Await">AssignmentExpression<emu-mods><emu-params>[?In, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>{</emu-t><emu-nt params="?Await">FunctionBody<emu-mods><emu-params>[?Await]</emu-params></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
    </emu-production>

    <emu-note><span class="note">Note</span>Await parameter added.</emu-note>
  </emu-clause>

  <emu-clause id="ExpressionStatement">
    <h1><span class="secnum">4.8</span><emu-nt>ExpressionStatement</emu-nt></h1>
    <emu-production name="ExpressionStatement" params="Yield, Await">
      <emu-nt params="Yield, Await">ExpressionStatement<emu-mods><emu-params>[Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-gann>[lookahead ∉ { <emu-t>{</emu-t>, <emu-t>function</emu-t>, <emu-t>class</emu-t>, <emu-t>let [</emu-t><ins>,<emu-t>async function</emu-t></ins>}]</emu-gann><emu-nt params="In, ?Yield, ?Await">Expression<emu-mods><emu-params>[In, ?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>
    </emu-production>
  </emu-clause>
</emu-clause>

<emu-annex id="todo">
  <h1><span class="secnum">A</span>Todo &amp; Known Issues</h1>
  <p>This list is not complete. It also does not duplicate any information on the <a href="https://github.com/tc39/ecmascript-asyncawait/issues">Github issues list</a>. It serves as a reminder to the author only.</p>
  <ol>
    <li>Updates to CreateDynamicFunction for creating dynamic async functions.</li>
    <li>Semantics (mostly runtime) for async methods.</li>
    <li>IteratorBindingInitialization runtime semantics.</li>
  </ol>
</emu-annex>
<emu-annex id="desugaring">
  <h1><span class="secnum">B</span>Informative Desugaring</h1>
  <pre><code class="hljs fortran">
async <span class="hljs-function"><span class="hljs-keyword">function</span></span> &lt;<span class="hljs-keyword">name</span>&gt;?&lt;argumentlist&gt;&lt;body&gt;

=&gt;

<span class="hljs-function"><span class="hljs-keyword">function</span></span> &lt;<span class="hljs-keyword">name</span>&gt;?&lt;argumentlist&gt;{ <span class="hljs-keyword">return</span> spawn(<span class="hljs-function"><span class="hljs-keyword">function</span></span>*() &lt;body&gt;, this); }
  </code></pre>

  <p>The <code>spawn</code> used in the above desugaring is a call to the following algorithm. This algorithm does not need to be exposed directly as an API to user code, it is part of the semantics of async functions.</p>

<pre><code language="javascript" class="hljs javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spawn</span>(<span class="hljs-params">genF, self</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
        <span class="hljs-keyword">var</span> gen = genF.call(self);
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step</span>(<span class="hljs-params">nextF</span>) </span>{
            <span class="hljs-keyword">var</span> next;
            <span class="hljs-keyword">try</span> {
                next = nextF();
            } <span class="hljs-keyword">catch</span>(e) {
                <span class="hljs-comment">// finished with failure, reject the promise</span>
                reject(e);
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">if</span>(next.done) {
                <span class="hljs-comment">// finished with success, resolve the promise</span>
                resolve(next.value);
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// not finished, chain off the yielded promise and `step` again</span>
            <span class="hljs-built_in">Promise</span>.resolve(next.value).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
                step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.next(v); });
            }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.throw(e); });
            });
        }
        step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.next(<span class="hljs-literal">undefined</span>); });
    });
}</code></pre>
</emu-annex>

</body>