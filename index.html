<!doctype html>
<head><meta charset="utf8">
<link rel="stylesheet" href="https://bterlson.github.com/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<style>
  emu-production.inline emu-mods {
    display: none;
  }

</style>

<title>Async Functions</title>
</head><body><h1>Async Functions</h1>
<div><h2>Table of Contents</h2><ol class="toc"><li><a href="#intro"><span class="secnum"></span> Introduction</a><ol class="toc"><li><a href="#status"><span class="secnum"></span> Status of this proposal</a></li><li><a href="#examples"><span class="secnum"></span> Examples</a></li></ol></li><li><a href="#async-function-definitions"><span class="secnum">1</span> Async Function Definitions</a><ol class="toc"><li><a href="#async-function-definition-static-semantics-early-errors"><span class="secnum">1.1</span> Static Semantics: Early Errors</a></li><li><a href="#async-function-definition-static-semantics-CoveredAsyncArrowHead"><span class="secnum">1.2</span> Static Semantics: CoveredAsyncArrowHead</a></li><li><a href="#async-function-definition-static-semantics-BoundNames"><span class="secnum">1.3</span> Static Semantics: BoundNames</a></li><li><a href="#async-function-definition-static-semantics-ComputedPropertyContains"><span class="secnum">1.4</span> Static Semantics: ComputedPropertyContains</a></li><li><a href="#async-function-definition-static-semantics-Contains"><span class="secnum">1.5</span> Static Semantics: Contains</a></li><li><a href="#async-function-definition-static-semantics-ContainsExpression"><span class="secnum">1.6</span> Static Semantics: ContainsExpression</a></li><li><a href="#async-function-definition-static-semantics-HasInitializer"><span class="secnum">1.7</span> Static Semantics: HasInitializer</a></li><li><a href="#async-function-definition-static-semantics-ExpectedArgumentCount"><span class="secnum">1.8</span> Static Semantics: ExpectedArgumentCount</a></li><li><a href="#async-function-definition-static-semantics-HasComputedPropertyKey"><span class="secnum">1.9</span> Static Semantics: HasComputedPropertyKey</a></li><li><a href="#async-function-definition-static-semantics-HasDirectSuper"><span class="secnum">1.10</span> Static Semantics: HasDirectSuper</a></li><li><a href="#async-function-definition-static-semantics-HasName"><span class="secnum">1.11</span> Static Semantics: HasName</a></li><li><a href="#async-function-definition-static-semantics-IsConstantDeclaration"><span class="secnum">1.12</span> Static Semantics: IsConstantDeclaration</a></li><li><a href="#async-function-definition-static-semantics-IsFunctionDefinition"><span class="secnum">1.13</span> Static Semantics: IsFunctionDefinition</a></li><li><a href="#async-function-definition-static-semantics-PropName"><span class="secnum">1.14</span> Static Semantics: PropName</a></li></ol></li><li><a href="#modified-productions"><span class="secnum">2</span> Modifications to existing productions</a><ol class="toc"><li><a href="#HoistableDeclaration"><span class="secnum">2.1</span> <emu-nt>HoistableDeclaration</emu-nt></a></li><li><a href="#PrimaryExpression"><span class="secnum">2.2</span> <emu-nt>PrimaryExpression</emu-nt></a></li><li><a href="#CallExpression"><span class="secnum">2.3</span> <emu-nt>CallExpression</emu-nt></a></li><li><a href="#UnaryExpression"><span class="secnum">2.4</span> <emu-nt>UnaryExpression</emu-nt></a></li><li><a href="#MethodDefinition"><span class="secnum">2.5</span> <emu-nt>MethodDefinition</emu-nt></a></li><li><a href="#AssignmentExpression"><span class="secnum">2.6</span> <emu-nt>AssignmentExpression</emu-nt></a></li><li><a href="#ConciseBody"><span class="secnum">2.7</span> <emu-nt>ConciseBody</emu-nt></a></li><li><a href="#ExpressionStatement"><span class="secnum">2.8</span> <emu-nt>ExpressionStatement</emu-nt></a></li></ol></li><li><a href="#desugaring"><span class="secnum">A</span> Informative Desugaring</a></li></ol></div><emu-intro id="intro">
  <h1><span class="secnum"></span>Introduction</h1>
  <p>The introduction of Promises and Generators in ECMAScript presents an opportunity to dramatically improve the language-level model for writing asynchronous code in ECMAScript.</p>

  <p>A similar proposal was made with <a href="http://wiki.ecmascript.org/doku.php?id=strawman:deferred_functions">Defered Functions</a> during ES6 discussions. The proposal here supports the same use cases, using similar or the same syntax, but directly building upon generators and promises instead of defining custom mechanisms.</p>

  <p>Development of this proposal is happening at <a href="https://github.com/tc39/ecmascript-asyncawait">https://github.com/tc39/ecmascript-asyncawait</a>. Please file issues there. Non-trivial contributions are limited to TC39 members but pull requests for minor issues are welcome and encouraged!</p>

  <emu-intro id="status">
    <h1><span class="secnum"></span>Status of this proposal</h1>

    <p>This proposal was accepted into stage 1 ("Proposal") of the ECMASCript 7 <a href="https://docs.google.com/document/d/1QbEE0BsO4lvl7NFTn5WXWeiEIBfaVUF7Dk0hpPpPDzU">spec process</a> in January 2014 (<a href="http://esdiscuss.org/notes/2014-01-30#async-await">discussion</a>).</p>
  </emu-intro>
  <emu-intro id="examples">
    <h1><span class="secnum"></span>Examples</h1>

    <p>Take the following example, first written using Promises. This code chains a set of animations on an element, stopping when there is an exception in an animation, and returning the value produced by the final succesfully executed animation.</p>

    <pre><code lang="javascript" class="hljs actionscript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsPromise</span><span class="hljs-params">(elem, animations)</span> </span>{
        <span class="hljs-keyword">var</span> ret = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> p = currentPromise;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> anim <span class="hljs-keyword">in</span> animations) {
            p = p.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val)</span> </span>{
                ret = val;
                <span class="hljs-keyword">return</span> anim(elem);
            })
        }
        <span class="hljs-keyword">return</span> p.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> </span>{
            <span class="hljs-comment">/* ignore and keep going */</span>
        }).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> ret;
        });
    }
    </code></pre>

    <p>Already with promises, the code is much improved from a straight callback style, where this sort of looping and exception handling is challenging.</p>
    

    <a href="http://taskjs.org">Task.js</a> and similar libraries offer a way to use generators to further simplify the code maintaining the same meaning:

    <pre><code class="javascript hljs">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsGenerator</span>(<span class="hljs-params">elem, animations</span>) </span>{
        <span class="hljs-keyword">return</span> spawn(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> ret = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> anim <span class="hljs-keyword">of</span> animations) {
                    ret = <span class="hljs-keyword">yield</span> anim(elem);
                }
            } <span class="hljs-keyword">catch</span>(e) { <span class="hljs-comment">/* ignore and keep going */</span> }
            <span class="hljs-keyword">return</span> ret;
        });
    }
    </code></pre>

    <p>This is a marked improvement. All of the promise boilerplate above and beyond the semantic content of the code is removed, and the body of the inner function represents user intent. However, there is an outer layer of boilerplate to wrap the code in an additional generator function and pass it to a library to convert to a promise. This layer needs to be repeated in every function that uses this mechanism to produce a promise. This is so common in typical async Javascript code, that there is value in removing the need for the remaining boilerplate.</p>

    <p>With async functions, all the remaining boiler plate is removed, leaving only the semantically meaningful code in the program text:</p>

    <pre><code class="javascript hljs">
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsAsync</span>(<span class="hljs-params">elem, animations</span>) </span>{
        <span class="hljs-keyword">var</span> ret = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> anim <span class="hljs-keyword">of</span> animations) {
                ret = <span class="hljs-keyword">await</span> anim(elem);
            }
        } <span class="hljs-keyword">catch</span>(e) { <span class="hljs-comment">/* ignore and keep going */</span> }
        <span class="hljs-keyword">return</span> ret;
    }
    </code></pre>

    <p>This is morally similar to generators, which are a function form that produces a Generator object. This new async function form produces a Promise object.</p>
  </emu-intro>
</emu-intro>
<emu-clause id="async-function-definitions">
  <h1><span class="secnum">1</span>Async Function Definitions</h1>

  <h2>Syntax</h2>
  <emu-production params="Yield, Await, Default" name="AsyncFunctionDeclaration">
    <emu-nt>AsyncFunctionDeclaration<emu-mods> [Yield, Await, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
    <emu-rhs constraints="+Default" a="2"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
  </emu-production>

  <emu-production name="AsyncFunctionExpression">
    <emu-nt>AsyncFunctionExpression<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="Await" optional="">BindingIdentifier<emu-mods> [Await] opt</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
  </emu-production>
  <!-- See also #async-function-definition-static-semantics-HasName -->

  <emu-production name="AsyncMethod">
    <emu-nt>AsyncMethod<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-nt>PropertyName<emu-mods></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
  </emu-production>


  <emu-production name="AsyncFunctionBody">
    <emu-nt>AsyncFunctionBody<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-nt params="Await">FunctionBody<emu-mods> [Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production>

  <emu-production name="AwaitExpression" params="Yield">
    <emu-nt>AwaitExpression<emu-mods> [Yield]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-t>await</emu-t><emu-nt params="?Yield, Await">UnaryExpression<emu-mods> [?Yield, Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production>

  <emu-note><span class="note">Note</span><code>yield</code> is <emu-nt>Identifier</emu-nt> or <emu-nt>YieldExpression</emu-nt> in <emu-nt>FunctionParameters</emu-nt> of <emu-nt>AsyncFunctionDeclaration</emu-nt> and <emu-nt>AsyncFunctionExpression</emu-nt> and <emu-nt>ArrowParameters</emu-nt> of <emu-nt>AsyncArrowFunction</emu-nt> depending on context. <code>await</code> is always parsed as an <emu-nt>AwaitExpression</emu-nt> but is a Syntax Error via static semantics. Yield is always allowed as an identifier of an <emu-nt>AsyncFunctionExpression</emu-nt>.</emu-note>


  <emu-production name="AsyncArrowFunction" params="In, Yield, Await">
    <emu-nt>AsyncArrowFunction<emu-mods> [In, Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods> [?Yield, Await]</emu-mods></emu-nt><emu-t>=&gt;</emu-t><emu-nt params="?In, Await">ConciseBody<emu-mods> [?In, Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production>

  <emu-production name="CoverCallExpressionAndAsyncArrowHead" params="Yield, Await">
    <emu-nt>CoverCallExpressionAndAsyncArrowHead<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-nt params="?Yield, ?Await">MemberExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-nt params="?Yield, ?Await">Arguments<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production>

  <emu-production name="AsyncArrowParameters" params="Yield, Await">
    <emu-nt>AsyncArrowParameters<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">BindingIdentifier<emu-mods> [?Yield, Await]</emu-mods></emu-nt></emu-rhs>
    <emu-rhs a="2"><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods> [?Yield, Await]</emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann></emu-rhs>
  </emu-production>

  <h3>Supplemental Syntax</h3>
  <p>When processing the production <emu-production name="AsyncArrowFunction" params="In, Yield, Await" a="1" class="inline">
    <emu-nt>AsyncArrowFunction<emu-mods> [In, Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods> [?Yield, Await]</emu-mods></emu-nt><emu-t>=&gt;</emu-t><emu-nt params="?In, Await">ConciseBody<emu-mods> [?In, Await]</emu-mods></emu-nt></emu-rhs></emu-production> the interpretation of <emu-nt>CoveredCallExpressionAndAsyncArrowHead</emu-nt> is refined using the following gramar:</p>

  <emu-production name="AsyncArrowHead" params="">
    <emu-nt>AsyncArrowHead<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-nt params="?Yield, Await">AsyncArrowParameters<emu-mods> [?Yield, Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production>

  <emu-clause id="async-function-definition-static-semantics-early-errors">
    <h1><span class="secnum">1.1</span>Static Semantics: Early Errors</h1>
    <p>
      <emu-production params="Yield, Await, Default" name="AsyncFunctionDeclaration" a="1" class="inline">
    <emu-nt>AsyncFunctionDeclaration<emu-mods> [Yield, Await, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
      <emu-production params="Yield, Await, Default" name="AsyncFunctionDeclaration" a="2" class="inline">
    <emu-nt>AsyncFunctionDeclaration<emu-mods> [Yield, Await, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs constraints="+Default" a="2"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
      <emu-production name="AsyncFunctionExpression" a="1" class="inline">
    <emu-nt>AsyncFunctionExpression<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="Await" optional="">BindingIdentifier<emu-mods> [Await] opt</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production>
    </p>
    <ul>
      <li>It is a Syntax Error if <emu-nt>FormalParameters</emu-nt> Contains <emu-nt>AwaitExpression</emu-nt> is <emu-val>true</emu-val>.
      </li><li>If the source code matching this production is strict code, the Early Error rules for <emu-nt>StrictFormalParameters</emu-nt> : <emu-nt>FormalParameters</emu-nt> are applied.
      </li><li>If the source code matching this production is strict code, it is a Syntax Error if <emu-nt>BindingIdentifier</emu-nt> is the <emu-nt>IdentifierName</emu-nt> <code>eval</code> or the <emu-nt>IdentifierName</emu-nt> <code>arguments</code>.
      </li><li>It is a Syntax Error if any element of the BoundNames of <emu-nt>FormalParameters</emu-nt> also occurs in the LexicallyDeclaredNames of <emu-nt>AsyncFunctionBody</emu-nt>.
      </li><li>It is a Syntax Error if <emu-nt>FormalParameters</emu-nt> contains <emu-nt>SuperProperty</emu-nt> is <emu-val>true</emu-val>.
      </li><li>It is a Syntax Error if <emu-nt>AsyncFunctionBody</emu-nt> contains <emu-nt>SuperProperty</emu-nt> is <emu-val>true</emu-val>.
    </li></ul>
    <p><emu-production name="AsyncMethod" a="1" class="inline">
    <emu-nt>AsyncMethod<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-nt>PropertyName<emu-mods></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
    <ul>
      <li>It is a Syntax Error if HasDirectSuper of <emu-nt>AsyncMethod</emu-nt> is <emu-val>true</emu-val>.
      </li><li>It is a Syntax Error if <emu-nt>StrictFormalParameters</emu-nt> Contains <emu-nt>AwaitExpression</emu-nt> is <emu-val>true</emu-val>.
      </li><li>It is a Syntax Error if any element of the BoundNames of <emu-nt>StrictFormalParameters</emu-nt> also occurs in the LexicallyDeclaredNames of <emu-nt>AsyncFunctionBody</emu-nt>
    </li></ul>
    <p><emu-production name="AsyncArrowFunction" params="In, Yield, Await" a="1" class="inline">
    <emu-nt>AsyncArrowFunction<emu-mods> [In, Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods> [?Yield, Await]</emu-mods></emu-nt><emu-t>=&gt;</emu-t><emu-nt params="?In, Await">ConciseBody<emu-mods> [?In, Await]</emu-mods></emu-nt></emu-rhs></emu-production></p>
    <ul>
      <li>It is a SyntaxError if the lexical token sequence matched by <emu-nt>CoverCallExpressionAndAsyncArrowHead</emu-nt> cannot be parsed with no tokens left over using <emu-nt>AsyncArrowHead</emu-nt> as the goal symbol.</li>
      <li>All Early Error rules for <emu-nt>AsyncArrowHead</emu-nt> and its derived productions apply to CoveredAsyncArrowHead of <emu-nt>CoverCallExpressionAndAsyncArrowHead</emu-nt>.</li>
    </ul>
    <p><emu-production name="AsyncArrowHead" params="" class="inline">
    <emu-nt>AsyncArrowHead<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-nt params="?Yield, Await">AsyncArrowParameters<emu-mods> [?Yield, Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production></p>
    <ul>
      <li>It is a SyntaxError if <emu-nt>AsyncArrowParameters</emu-nt> Contains <emu-nt>YieldExpression</emu-nt> is true.
      </li><li>It is a SyntaxError if <emu-nt>AsyncArrowParameters</emu-nt> Contains <emu-nt>AwaitExpression</emu-nt> is true.
      </li><li>It is a Syntax Error if any element of the BoundNames of <emu-nt>AsyncArrowParameters</emu-nt> also occurs in the LexicallyDeclaredNames of <emu-nt>ConciseBody</emu-nt>.
    </li></ul>
  </emu-clause>

  <emu-clause id="async-function-definition-static-semantics-CoveredAsyncArrowHead">
    <h1><span class="secnum">1.2</span>Static Semantics: CoveredAsyncArrowHead</h1>
    <p><emu-production name="CoverCallExpressionAndAsyncArrowHead" params="Yield, Await">
    <emu-nt>CoverCallExpressionAndAsyncArrowHead<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-nt params="?Yield, ?Await">MemberExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-nt params="?Yield, ?Await">Arguments<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production></p>
    <ul>
      <li>Return the result of parsing the lexical token stream matched by <emu-nt>CoveredCallExpressionAndAsyncArrowHead</emu-nt><sub>[Yield, Await]</sub> using either <emu-nt>AsyncArrowHead</emu-nt>, <emu-nt>AsyncArrowHead</emu-nt><sub>[Yield]</sub>, <emu-nt>AsyncArrowHead</emu-nt><sub>[Await]</sub>, or <emu-nt>AsyncArrowHead</emu-nt><sub>[Yield, Await]</sub> as the goal symbol depending upon whether the <sub>[Yield]</sub> and <sub>[Await]</sub> grammar parameters were present when <emu-nt>CoveredCallExpressionAndAsyncArrowHead</emu-nt> was matched.</li>
    </ul>
  </emu-clause>

  <emu-clause id="async-function-definition-static-semantics-BoundNames">
    <h1><span class="secnum">1.3</span>Static Semantics: BoundNames</h1>
    <p><emu-production params="Yield, Await, Default" name="AsyncFunctionDeclaration" a="1" class="inline">
    <emu-nt>AsyncFunctionDeclaration<emu-mods> [Yield, Await, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
    <emu-alg><ol>
  <li>Return the BoundNames of <emu-nt>BindingIdentifier</emu-nt>.</li>
</ol></emu-alg>
    <p><emu-production params="Yield, Await, Default" name="AsyncFunctionDeclaration" a="2" class="inline">
    <emu-nt>AsyncFunctionDeclaration<emu-mods> [Yield, Await, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs constraints="+Default" a="2"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production></p>
    <emu-alg><ol>
  <li>Return «<code>"*default*"</code>».</li>
</ol></emu-alg>
    <emu-note><span class="note">Note</span>"<emu-val>default</emu-val>" is used within this specification as a synthetic name for hoistable anonymous functions that are defined using export declarations.</emu-note>
    <p><emu-production name="AsyncArrowParameters" params="Yield, Await" a="1" class="inline">
    <emu-nt>AsyncArrowParameters<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">BindingIdentifier<emu-mods> [?Yield, Await]</emu-mods></emu-nt></emu-rhs></emu-production></p>
    <emu-alg><ol>
  <li>Return the BoundNames of <emu-nt>BindingIdentifier</emu-nt>.</li>
</ol></emu-alg>
    <p><emu-production name="AsyncArrowParameters" params="Yield, Await" a="2" class="inline">
    <emu-nt>AsyncArrowParameters<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="2"><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods> [?Yield, Await]</emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann></emu-rhs></emu-production></p>
    <emu-alg><ol>
  <li>Return the BoundNames of <emu-nt>ArrowFormalParameters</emu-nt>.</li>
</ol></emu-alg>
  </emu-clause>

  <emu-clause id="async-function-definition-static-semantics-ComputedPropertyContains">
    <h1><span class="secnum">1.4</span>Static Semantics: ComputedPropertyContains</h1>
    <p>With parameter <var>symbol</var>.</p>
    <p><emu-production name="AsyncMethod" class="inline">
    <emu-nt>AsyncMethod<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-nt>PropertyName<emu-mods></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
  </emu-production></p>
    <emu-alg><ol>
  <li>Return the result of ComputedPropertyContains for <emu-nt>PropertyName</emu-nt> with argument <var>symbol</var>.</li>
</ol></emu-alg>
  </emu-clause>

  <emu-clause id="async-function-definition-static-semantics-Contains">
    <h1><span class="secnum">1.5</span>Static Semantics: Contains</h1>
    <p>With parameter <var>symbol</var>.</p>
    <p>
      <emu-production params="Yield, Await, Default" name="AsyncFunctionDeclaration" a="1" class="inline">
    <emu-nt>AsyncFunctionDeclaration<emu-mods> [Yield, Await, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
      <emu-production params="Yield, Await, Default" name="AsyncFunctionDeclaration" a="2" class="inline">
    <emu-nt>AsyncFunctionDeclaration<emu-mods> [Yield, Await, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs constraints="+Default" a="2"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
      <emu-production name="AsyncFunctionExpression" class="inline">
    <emu-nt>AsyncFunctionExpression<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="Await" optional="">BindingIdentifier<emu-mods> [Await] opt</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
  </emu-production>
    </p>
    <emu-alg><ol>
  <li>Return <emu-val>false</emu-val>.</li>
</ol></emu-alg>
    <emu-note><span class="note">Note 1</span>Could probably check if <var>symbol</var> is one of these declarations or expressions, but this is not done in current spec and may not be necessary. See also: <a href="https://bugs.ecmascript.org/show_bug.cgi?id=4383">https://bugs.ecmascript.org/show_bug.cgi?id=4383</a>.</emu-note>
    <p><emu-production name="AsyncArrowFunction" params="In, Yield, Await" class="inline">
    <emu-nt>AsyncArrowFunction<emu-mods> [In, Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods> [?Yield, Await]</emu-mods></emu-nt><emu-t>=&gt;</emu-t><emu-nt params="?In, Await">ConciseBody<emu-mods> [?In, Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production></p>
    <emu-alg><ol>
  <li>If <var>symbol</var> is not one of <emu-nt>NewTarget</emu-nt>, <emu-nt>SuperProperty</emu-nt>, <emu-nt>SuperCall</emu-nt>,
    <emu-t>super</emu-t>, or
    <emu-t>this</emu-t>, return <emu-val>false</emu-val>.</li>
  <li>Let <var>head</var> be CoveredAsyncFunctionHead of <emu-nt>CoveredCallExpressionAndAsyncArrowHead</emu-nt>.</li>
  <li>If <var>head</var> Contains <var>symbol</var> is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li>
  <li>return <emu-nt>ConciseBody</emu-nt> Contains <var>symbol</var>.</li>
</ol></emu-alg>
    <emu-note><span class="note">Note 2</span>Normally, Contains does not look inside most function forms. However, Contains is used to detect <code>new.target</code>, <code>this</code>, and <code>super</code> usage within an AsyncArrowFunction.</emu-note>
    <p><emu-production name="AsyncArrowHead" params="" class="inline">
    <emu-nt>AsyncArrowHead<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-nt params="?Yield, Await">AsyncArrowParameters<emu-mods> [?Yield, Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production></p>
    <emu-alg><ol>
  <li>return <emu-nt>AsyncArrowParameters</emu-nt> Contains <var>symbol</var>.</li>
</ol></emu-alg>
  </emu-clause>

  <emu-clause id="async-function-definition-static-semantics-ContainsExpression">
    <h1><span class="secnum">1.6</span>Static Semantics: ContainsExpression</h1>
    <p><emu-production name="AsyncArrowFunction" params="In, Yield, Await" class="inline">
    <emu-nt>AsyncArrowFunction<emu-mods> [In, Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods> [?Yield, Await]</emu-mods></emu-nt><emu-t>=&gt;</emu-t><emu-nt params="?In, Await">ConciseBody<emu-mods> [?In, Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production></p>
    <emu-alg><ol>
  <li>Let <var>head</var> be CoveredAsyncFunctionHead of <emu-nt>CoveredCallExpressionAndAsyncArrowHead</emu-nt>.</li>
  <li>Return ContainsExpression of <var>head</var>.</li>
</ol></emu-alg>

    <p><emu-production name="AsyncArrowHead" params="" class="inline">
    <emu-nt>AsyncArrowHead<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-nt params="?Yield, Await">AsyncArrowParameters<emu-mods> [?Yield, Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production></p>
    <emu-alg><ol>
  <li>Return ContainsExpression of <emu-nt>AsyncArrowParameters</emu-nt>.</li>
</ol></emu-alg>

    <p><emu-production name="AsyncArrowParameters" params="Yield, Await" class="inline" a="1">
    <emu-nt>AsyncArrowParameters<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">BindingIdentifier<emu-mods> [?Yield, Await]</emu-mods></emu-nt></emu-rhs></emu-production></p>
    <emu-alg><ol>
  <li>Return <emu-val>false</emu-val>.</li>
</ol></emu-alg>

    <p><emu-production name="AsyncArrowParameters" params="Yield, Await" class="inline" a="2">
    <emu-nt>AsyncArrowParameters<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="2"><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods> [?Yield, Await]</emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann></emu-rhs></emu-production></p>

    <emu-alg><ol>
  <li>Return ContainsExpression of <emu-nt>ArrowFormalParameters</emu-nt>.</li>
</ol></emu-alg>
  </emu-clause>

  <emu-clause id="async-function-definition-static-semantics-HasInitializer">
    <h1><span class="secnum">1.7</span>Static Semantics: HasInitializer</h1>
    <p><emu-production name="AsyncArrowParameters" params="Yield, Await" class="inline" a="1">
    <emu-nt>AsyncArrowParameters<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">BindingIdentifier<emu-mods> [?Yield, Await]</emu-mods></emu-nt></emu-rhs></emu-production></p>
    <emu-alg><ol>
  <li>Return <emu-val>false</emu-val>.</li>
</ol></emu-alg>

    <p><emu-production name="AsyncArrowParameters" params="Yield, Await" class="inline" a="2">
    <emu-nt>AsyncArrowParameters<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="2"><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods> [?Yield, Await]</emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann></emu-rhs></emu-production></p>

    <emu-alg><ol>
  <li>Return HasInitializer of <emu-nt>ArrowFormalParameters</emu-nt>.</li>
</ol></emu-alg>
  </emu-clause>

  <emu-clause id="async-function-definition-static-semantics-ExpectedArgumentCount">
    <h1><span class="secnum">1.8</span>Static Semantics: ExpectedArgumentCount</h1>
    <p><emu-production name="AsyncArrowParameters" params="Yield, Await" class="inline" a="1">
    <emu-nt>AsyncArrowParameters<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">BindingIdentifier<emu-mods> [?Yield, Await]</emu-mods></emu-nt></emu-rhs></emu-production></p>
    <emu-alg><ol>
  <li>Return <emu-val>1</emu-val>.</li>
</ol></emu-alg>

    <p><emu-production name="AsyncArrowParameters" params="Yield, Await" class="inline" a="2">
    <emu-nt>AsyncArrowParameters<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="2"><emu-nt params="?Yield, Await">ArrowFormalParameters<emu-mods> [?Yield, Await]</emu-mods></emu-nt><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann></emu-rhs></emu-production></p>

    <emu-alg><ol>
  <li>Return ExpectedArgumentCount of <emu-nt>ArrowFormalParameters</emu-nt>.</li>
</ol></emu-alg>
  </emu-clause>

  <emu-clause id="async-function-definition-static-semantics-HasComputedPropertyKey">
    <h1><span class="secnum">1.9</span>Static Semantics: HasComputedPropertyKey</h1>
    <p><emu-production name="AsyncMethod" class="inline">
    <emu-nt>AsyncMethod<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-nt>PropertyName<emu-mods></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
  </emu-production></p>
    <emu-alg><ol>
  <li>Return IsComputedPropertyKey of <var>PropertyName</var>.</li>
</ol></emu-alg>
  </emu-clause>

  <emu-clause id="async-function-definition-static-semantics-HasDirectSuper">
    <h1><span class="secnum">1.10</span>Static Semantics: HasDirectSuper</h1>
    <p>
      <emu-production params="Yield, Await, Default" name="AsyncFunctionDeclaration" a="1" class="inline">
    <emu-nt>AsyncFunctionDeclaration<emu-mods> [Yield, Await, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
      <emu-production params="Yield, Await, Default" name="AsyncFunctionDeclaration" a="2" class="inline">
    <emu-nt>AsyncFunctionDeclaration<emu-mods> [Yield, Await, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs constraints="+Default" a="2"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
      <emu-production name="AsyncFunctionExpression" class="inline">
    <emu-nt>AsyncFunctionExpression<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="Await" optional="">BindingIdentifier<emu-mods> [Await] opt</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
  </emu-production>
    </p>
    <emu-alg><ol>
  <li>If <emu-nt>FormalParameters</emu-nt> Contains <emu-nt>SuperCall</emu-nt> is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li>
  <li>Return <emu-nt>AsyncFunctionBody</emu-nt> Contains <emu-nt>SuperCall</emu-nt>.</li>
</ol></emu-alg>
    <p>
      <emu-production name="AsyncMethod" class="inline">
    <emu-nt>AsyncMethod<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-nt>PropertyName<emu-mods></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
  </emu-production>
    </p>
    <emu-alg><ol>
  <li>If <emu-nt>StrictFormalParameters</emu-nt> Contains <emu-nt>SuperCall</emu-nt> is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li>
  <li>Return <emu-nt>AsyncFunctionBody</emu-nt> Contains <emu-nt>SuperCall</emu-nt>.</li>
</ol></emu-alg>
  </emu-clause>
  <emu-clause id="async-function-definition-static-semantics-HasName">
    <h1><span class="secnum">1.11</span>Static Semantics: HasName</h1>
    <p><emu-production name="AsyncFunctionExpression" class="inline">
      <emu-nt>AsyncFunctionExpression<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
    </emu-production></p>
    <emu-alg><ol>
  <li>Return <emu-val>false</emu-val>.</li>
</ol></emu-alg>
    <p><emu-production name="AsyncFunctionExpression" class="inline">
      <emu-nt>AsyncFunctionExpression<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="Await">BindingIdentifier<emu-mods> [Await]</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
    </emu-production></p>
    <emu-alg><ol>
  <li>Return <emu-val>true</emu-val>.</li>
</ol></emu-alg>
    <p><emu-production name="AsyncArrowFunction" params="In, Yield, Await" class="inline">
    <emu-nt>AsyncArrowFunction<emu-mods> [In, Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-nt params="?Yield, Await">CoverCallExpressionAndAsyncArrowHead<emu-mods> [?Yield, Await]</emu-mods></emu-nt><emu-t>=&gt;</emu-t><emu-nt params="?In, Await">ConciseBody<emu-mods> [?In, Await]</emu-mods></emu-nt></emu-rhs>
  </emu-production></p>
    <emu-alg><ol>
  <li>Return <emu-val>false</emu-val>.</li>
</ol></emu-alg>
  </emu-clause> 
  <emu-clause id="async-function-definition-static-semantics-IsConstantDeclaration">
    <h1><span class="secnum">1.12</span>Static Semantics: IsConstantDeclaration</h1>
    <p>
      <emu-production params="Yield, Await, Default" name="AsyncFunctionDeclaration" a="1" class="inline">
    <emu-nt>AsyncFunctionDeclaration<emu-mods> [Yield, Await, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="?Yield, ?Await">BindingIdentifier<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
      <emu-production params="Yield, Await, Default" name="AsyncFunctionDeclaration" a="2" class="inline">
    <emu-nt>AsyncFunctionDeclaration<emu-mods> [Yield, Await, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs constraints="+Default" a="2"><emu-constraints>[+Default]</emu-constraints><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs></emu-production><br>
    </p>
    <emu-alg><ol>
  <li>Return <emu-val>true</emu-val>.</li>
</ol></emu-alg>
  </emu-clause>
  <emu-clause id="async-function-definition-static-semantics-IsFunctionDefinition">
    <h1><span class="secnum">1.13</span>Static Semantics: IsFunctionDefinition</h1>
    <p>
      <emu-production name="AsyncFunctionExpression" class="inline">
    <emu-nt>AsyncFunctionExpression<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-t>function</emu-t><emu-nt params="Await" optional="">BindingIdentifier<emu-mods> [Await] opt</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">FormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
  </emu-production><br>
    </p>
    <emu-alg><ol>
  <li>Return <emu-val>true</emu-val>.</li>
</ol></emu-alg>
  </emu-clause>
  <emu-clause id="async-function-definition-static-semantics-PropName">
    <h1><span class="secnum">1.14</span>Static Semantics: PropName</h1>
    <p>
      <emu-production name="AsyncMethod" class="inline">
    <emu-nt>AsyncMethod<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a="1"><emu-t>async</emu-t><emu-gann>[no <emu-nt>LineTerminator<emu-mods></emu-mods></emu-nt> here]</emu-gann><emu-nt>PropertyName<emu-mods></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params="Await">StrictFormalParameters<emu-mods> [Await]</emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>AsyncFunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
  </emu-production><br>
    </p>
    <emu-alg><ol>
  <li>Return PropName of <emu-nt>PropertyName</emu-nt>.</li>
</ol></emu-alg>
  </emu-clause>
</emu-clause>
<emu-clause id="modified-productions">
  <h1><span class="secnum">2</span>Modifications to existing productions</h1>
  <p>Unless otherwise defined in this section, every production that includes a <code>Yield</code> parameter is modified to include an <code>Await</code> parameter and any Non-terminal with a <code>?Yield</code> parameter is modified to include an <code>?Await</code> parameter.</p>

  <emu-clause id="HoistableDeclaration">
    <h1><span class="secnum">2.1</span><emu-nt>HoistableDeclaration</emu-nt></h1>
    <emu-production name="HoistableDeclaration" params="Yield, Default">
      <emu-nt>HoistableDeclaration<emu-mods> [Yield, Default]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-nt params="?Yield, ?Default">FunctionDeclaration<emu-mods> [?Yield, ?Default]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Default">GeneratorDeclaration<emu-mods> [?Yield, ?Default]</emu-mods></emu-nt></emu-rhs>
      <ins class="block"><emu-rhs><emu-nt params="?Yield, ?Default">AsyncFunctionDeclaration<emu-mods> [?Yield, ?Default]</emu-mods></emu-nt></emu-rhs></ins>
    </emu-production>
  </emu-clause>

  <emu-clause id="PrimaryExpression">
    <h1><span class="secnum">2.2</span><emu-nt>PrimaryExpression</emu-nt></h1>
    <emu-production name="PrimaryExpression" params="Yield, Await">
      <emu-nt>PrimaryExpression<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-t>this</emu-t></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">IdentifierReference<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs> 
      <emu-rhs><emu-nt>Literal<emu-mods></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">ArrayLiteral<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs> 
      <emu-rhs><emu-nt params="?Yield, ?Await">ObjectLiteral<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs> 
      <emu-rhs><emu-nt>FunctionExpression<emu-mods></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">ClassExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Await">GeneratorExpression<emu-mods> [?Await]</emu-mods></emu-nt></emu-rhs>
      <ins class="block"><emu-rhs><emu-nt params="?Yield">AsyncFunctionExpression<emu-mods> [?Yield]</emu-mods></emu-nt></emu-rhs></ins>
      <emu-rhs><emu-nt>RegularExpressionLiteral<emu-mods></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield">TemplateLiteral<emu-mods> [?Yield]</emu-mods></emu-nt></emu-rhs>
    </emu-production>
  </emu-clause>

  <emu-clause id="CallExpression">
    <h1><span class="secnum">2.3</span><emu-nt>CallExpression</emu-nt></h1>
    <emu-production name="CallExpression" params="Yield, Await">
      <emu-nt>CallExpression<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><ins class="block">
        <emu-rhs><emu-nt params="?Yield, ?Await">CoverCallExpressionAndAsyncArrowHead<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      </ins>
      <del class="block">
        <emu-rhs><emu-nt params="?Yield, ?Await">MemberExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-nt params="?Yield, ?Await">Arguments<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      </del>
      <emu-rhs><emu-nt params="?Yield, ?Await">SuperCall<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">CallExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-nt params="?Yield, ?Await">Arguments<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">CallExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>[</emu-t><emu-nt params="In, ?Yield, ?Await">Expression<emu-mods> [In, ?Yield, ?Await]</emu-mods></emu-nt><emu-t>]</emu-t></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">CallExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>.</emu-t><emu-nt>IdentifierName<emu-mods></emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">CallExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-nt params="?Yield, ?Await">TemplateLiteral<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
    </emu-production>
  </emu-clause>

  <emu-clause id="UnaryExpression">
    <h1><span class="secnum">2.4</span><emu-nt>UnaryExpression</emu-nt></h1>
    <emu-production name="UnaryExpression" params="Yield, Await">
      <emu-nt>UnaryExpression<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-nt params="?Yield, ?Await">PostfixExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>delete</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>void</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>typeof</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>++</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>--</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>+</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>-</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>~</emu-t><emu-nt params="?Yield, ?Await">UnaryExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <ins class="block"><emu-rhs constraints="+Await"><emu-constraints>[+Await]</emu-constraints><emu-nt params="?Yield">AwaitExpression<emu-mods> [?Yield]</emu-mods></emu-nt></emu-rhs></ins>
    </emu-production>

    <emu-note><span class="note">Note</span>Currently it is not possible for an <emu-nt>AwaitExpression</emu-nt> and a <emu-nt>YieldExpression</emu-nt> to be parsed together, so technically passing the <code>?Yield</code> parameter for <emu-production name="UnaryExpression" class="inline"><emu-nt>UnaryExpression<emu-mods></emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs constraints="+Await"><emu-constraints>[+Await]</emu-constraints><emu-t>await</emu-t><emu-nt params="?Yield, Await">UnaryExpression<emu-mods> [?Yield, Await]</emu-mods></emu-nt></emu-rhs></emu-production> is unnecessary. It will probably be useful for AsyncGenerators however.</emu-note>
  </emu-clause>

  <emu-clause id="MethodDefinition">
    <h1><span class="secnum">2.5</span><emu-nt>MethodDefinition</emu-nt></h1>
    <emu-production name="MethodDefinition" params="Yield, Await">
      <emu-nt>MethodDefinition<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-nt params="?Yield, ?Await">PropertyName<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt>StrictFormalParameters<emu-mods></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>FunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">GeneratorMethod<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <ins class="block"><emu-rhs><emu-nt params="?Yield, ?Await">AsyncMethod<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt></emu-rhs></ins>
      <emu-rhs><emu-t>get</emu-t><emu-nt params="?Yield, ?Await">PropertyName<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>(</emu-t><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>FunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
      <emu-rhs><emu-t>set</emu-t><emu-nt params="?Yield, ?Await">PropertyName<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>(</emu-t><emu-nt>PropertySetParameterList<emu-mods></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt>FunctionBody<emu-mods></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
    </emu-production>
  </emu-clause>

  <emu-clause id="AssignmentExpression">
    <h1><span class="secnum">2.6</span><emu-nt>AssignmentExpression</emu-nt></h1>
    <emu-production name="AssignmentExpression" params="In, Yield, Await">
      <emu-nt>AssignmentExpression<emu-mods> [In, Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-nt params="?In, ?Yield, ?Await">ConditionalExpression<emu-mods> [?In, ?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs constraints="+Yield"><emu-constraints>[+Yield]</emu-constraints><emu-nt params="?In, ?Await">YieldExpression<emu-mods> [?In, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?In, ?Yield, ?Await">ArrowFunction<emu-mods> [?In, ?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <ins class="block"><emu-rhs><emu-nt params="?In, ?Yield">AsyncArrowFunction<emu-mods> [?In, ?Yield]</emu-mods></emu-nt></emu-rhs></ins>
      <emu-rhs><emu-nt params="?Yield, ?Await">LeftHandSideExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-t>=</emu-t><emu-nt params="?In, ?Yield, ?Await">AssignmentExpression<emu-mods> [?In, ?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-nt params="?Yield, ?Await">LeftHandSideExpression<emu-mods> [?Yield, ?Await]</emu-mods></emu-nt><emu-nt>AssignmentOperator<emu-mods></emu-mods></emu-nt><emu-nt params="?In, ?Yield, ?Await">AssignmentExpression<emu-mods> [?In, ?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
    </emu-production>
  </emu-clause>

  <emu-clause id="ConciseBody">
    <h1><span class="secnum">2.7</span><emu-nt>ConciseBody</emu-nt></h1>
    <emu-production name="ConciseBody" params="In, Await">
      <emu-nt>ConciseBody<emu-mods> [In, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-gann>[lookahead ≠ {]</emu-gann><emu-nt params="?In, ?Await">AssignmentExpression<emu-mods> [?In, ?Await]</emu-mods></emu-nt></emu-rhs>
      <emu-rhs><emu-t>{</emu-t><emu-nt params="?Await">FunctionBody<emu-mods> [?Await]</emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>
    </emu-production>

    <emu-note><span class="note">Note</span>Await parameter added.</emu-note>
  </emu-clause>

  <emu-clause id="ExpressionStatement">
    <h1><span class="secnum">2.8</span><emu-nt>ExpressionStatement</emu-nt></h1>
    <emu-production name="ExpressionStatement" params="Yield, Await">
      <emu-nt>ExpressionStatement<emu-mods> [Yield, Await]</emu-mods><emu-mods></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs><emu-gann>[lookahead ∉ { <emu-t>{</emu-t>, <emu-t>function</emu-t>, <emu-t>class</emu-t>, <emu-t>let [</emu-t><ins>,<emu-t>async function</emu-t></ins>}]</emu-gann><emu-nt params="In, ?Yield, ?Await">Expression<emu-mods> [In, ?Yield, ?Await]</emu-mods></emu-nt></emu-rhs>
    </emu-production>
  </emu-clause>
</emu-clause>

<emu-annex id="desugaring">
  <h1><span class="secnum">A</span>Informative Desugaring</h1>
  <pre><code class="hljs fortran">
async <span class="hljs-function"><span class="hljs-keyword">function</span></span> &lt;<span class="hljs-keyword">name</span>&gt;?&lt;argumentlist&gt;&lt;body&gt;

=&gt;

<span class="hljs-function"><span class="hljs-keyword">function</span></span> &lt;<span class="hljs-keyword">name</span>&gt;?&lt;argumentlist&gt;{ <span class="hljs-keyword">return</span> spawn(<span class="hljs-function"><span class="hljs-keyword">function</span></span>*() &lt;body&gt;, this); }
  </code></pre>

  <p>The <code>spawn</code> used in the above desugaring is a call to the following algorithm. This algorithm does not need to be exposed directly as an API to user code, it is part of the semantics of async functions.</p>

<pre><code language="javascript" class="hljs javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spawn</span>(<span class="hljs-params">genF, self</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
        <span class="hljs-keyword">var</span> gen = genF.call(self);
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step</span>(<span class="hljs-params">nextF</span>) </span>{
            <span class="hljs-keyword">var</span> next;
            <span class="hljs-keyword">try</span> {
                next = nextF();
            } <span class="hljs-keyword">catch</span>(e) {
                <span class="hljs-comment">// finished with failure, reject the promise</span>
                reject(e);
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">if</span>(next.done) {
                <span class="hljs-comment">// finished with success, resolve the promise</span>
                resolve(next.value);
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// not finished, chain off the yielded promise and `step` again</span>
            <span class="hljs-built_in">Promise</span>.resolve(next.value).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
                step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.next(v); });
            }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.throw(e); });
            });
        }
        step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.next(<span class="hljs-literal">undefined</span>); });
    });
}</code></pre>
</emu-annex>
</body>