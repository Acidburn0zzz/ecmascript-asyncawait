<emu-clause id="async-function-definitions-InstantiateFunctionObject">
  <h1>Runtime Semantics: InstantiateFunctionObject</h1>
  <p>With parameter _scope_.</p>
  <p><emu-prodref name="AsyncFunctionDeclaration" a="1" class="inline"></emu-prodref></p>
  <emu-alg>
    1. If the function code for |AsyncFunctionDeclaration| is strict mode code, let _strict_ be *true*. Otherwise, let _strict_ be *false*.
    2. Let _name_ be StringValue of |BindingIdentifier|
    3. Let _F_ be AsyncFunctionCreate(~Normal~, |FormalParameters|, |AsyncFunctionBody|, _scope_, _strict_).
    4. Perform SetFunctionName(_F_, _name_).
  </emu-alg>
  <p><emu-prodref name="AsyncFunctionDeclaration" a="2" class="inline"></emu-prodref></p>
  <emu-alg>
    1. If the function code for |AsyncFunctionDeclaration| is strict mode code, let _strict_ be *true*. Otherwise, let _strict_ be *false*.
    2. Let _F_ be AsyncFunctionCreate(~Normal~, |FormalParameters|, |AsyncFunctionBody|, _scope_, _strict_).
    3. Perform SetFunctionName(_F_, "default").
  </emu-alg>
</emu-clause>

<emu-clause id="async-function-definitions-EvaluateBody">
  <h1>Runtime Semantics: EvaluateBody</h1>
  <p>With parameter _functionObject_.</p>
  <p>
    <emu-prodref name="AsyncFunctionBody" a="1" class="inline"></emu-prodref><br>
    <emu-prodref name="AsyncConciseBody" a="1" class="inline"></emu-prodref>
  </p>
  <emu-alg>
    1. Let _promiseCapability_ be NewPromiseCapability(%Promise%).
    2. ReturnIfAbrupt(_promiseCapability_).
    3. Let _G_ be ObjectCreate(%GeneratorPrototype%, «[[GeneratorState]], [[GeneratorContext]]» ).
    4. ReturnIfAbrupt(_G_).
    5. Perform GeneratorStart(_G_, _FunctionBody_).
    6. Perform AsyncFunctionStart(_G_, _promiseCapability_).
    6. Return Completion{[[type]]: return, [[value]]: _promiseCapability_.[[Promise]], [[target]]: empty}.
  </emu-alg>

  <p><emu-prodref name="AsyncConciseBody" a="2" class="inline"></emu-prodref></p>
  <emu-alg>
    1. Return the result of calling EvaluateBody of |AsyncFunctionBody|.
  </emu-alg>
</emu-clause>

<emu-clause id="async-function-definitions-AsyncFunctionStart" aoid="AsyncFunctionStart">
  <h1>Runtime Semantics: AsyncFunctionStart</h1>
  <p>With parameters _generator_, _promiseCapability_, _operation_, and _value_. The parameters _operation_ and _value_ are optional.</p>
  <emu-note>This function does not return any important abrupt completions so in some cases they are ignored. In other cases, callers should ignore any abrupt completion values. Errors as a result of ticking forward the generator will be propagated as promise rejections. All other errors (such as those resulting from getting generator methods, calling Promise.resolve, or p.then) are ignored. It is possible that we can be statically assured that no errors will result from this algorithm.</emu-note>
  <emu-alg>
    1. If _operation_ was not provided, let _operation_ be "next".
    1. If _value_ was not provided, let _value_ be *undefined*.
    1. let _operationFn_ be the result of Get(_generator_, _operation_).
    1. ReturnIfAbrupt(_operationFn_).
    1. let _result_ be Call(_next_, _generator_).
    1. If _result_ is an abrupt completion, then
        1. Perform Call(_promiseCapability_.[[reject]], *undefined*, «_result_.value»)
        1. Return.
    1. Assert: The async function has either awaited something or returned something.
    1. let _done_ be Get(_result_, "done").
    1. ReturnIfAbrupt(_done_).
    1. If _done_ is *true*, then
        1. Perform Call(_promiseCapability_.[[resolve]], *undefined*, «_result_.value»).
        1. Return.
    1. Assert: _done_ is false, _result_.value is a value that has come out of the generator.
    1. let _awaitedPromise_ be the result of Call(%Promise%.resolve, %Promise%, «_result_.value»).
    1. let _promiseResolved_ be a new built-in function object as defined in <a href="#async-function-definitions-awaited-resolved">AsyncFunction Awaited Resolved</a>.
    1. Set the [[Generator]] internal slot of _promiseResolved_ to _generator_.
    1. Set the [[PromiseCapability]] internal slot of _promiseResolved_ to _promiseCapability_.
    1. let _promiseRejected_ be a new built-in function object as defined in <a href="#async-function-definitions-awaited-rejected">AsyncFunction Awaited Rejected</a>.
    1. Set the [[Generator]] internal slot of _promiseRejected_ to _generator_.
    1. Set the [[PromiseCapability]] internal slot of _promiseRejected_ to _promiseCapability_.
    1. Invoke(_awaitedPromise_, "then", «_promiseResolved_, _promiseRejected_»).
    1. Return.
  </emu-alg>
</emu-clause>

<emu-clause id="async-function-definitions-awaited-resolved">
  <h1>AsyncFunction Awaited Resolved</h1>
  <p>Function _F_ is called with the parameter _value_.</p>
  <emu-alg>
    1. let _generator_ be the value of _F_'s [[Generator]] internal slot.
    1. let _promiseCapability_ be the value of _F_'s [[PromiseCapability]] internal slot.
    1. return the result of performing AsyncFunctionStart(_generator_, _promiseCapability_, "next", _value_).
  </emu-alg>
</emu-clause>

<emu-clause id="async-function-definitions-awaited-rejected">
  <h1>AsyncFunction Awaited Rejected</h1>
  <p>Function _F_ is called with the parameter _value_.</p>
  <emu-alg>
    1. let _generator_ be the value of _F_'s [[Generator]] internal slot.
    1. let _promiseCapability_ be the value of _F_'s [[PromiseCapability]] internal slot.
    1. return the result of performing AsyncFunctionStart(_generator_, _promiseCapability_, "throw", _value_).
  </emu-alg>
</emu-clause>

<emu-clause id="async-function-definitions-runtime-semantics-evaluation">
  <h1>Runtime Semantics: Evaluation</h1>
  <p><emu-prodref name="AsyncFunctionDeclaration" a="1" class="inline"></emu-prodref></p>
  <emu-alg>
    1. Return.
  </emu-alg>

  <p><emu-prodref name="AsyncFunctionDeclaration" a="2" class="inline"></emu-prodref></p>
  <emu-alg>
    1. Return.
  </emu-alg>

  <p><emu-prodref name="AsyncArrowFunction" a="1" class="inline"></emu-prodref></p>
  <emu-alg>
    1. If the function code for this |AsyncArrowFunction| is strict mode code, let _strict_ be true. Otherwise, let _strict_ be false.
    2. Let _scope_ be the LexicalEnvironment of the running execution context.
    3. Let _parameters_ be |AsyncArrowBindingIdentifier|.
    4. Let _closure_ be AsyncFunctionCreate("Arrow", _parameters_, |ConciseBody|, _scope_, _strict_).
    5. Return _closure_.
  </emu-alg>

  <p><emu-prodref name="AsyncArrowFunction" a="2" class="inline"></emu-prodref></p>
  <emu-alg>
    1. If the function code for this |AsyncArrowFunction| is strict mode code, let _strict_ be true. Otherwise, let _strict_ be false.
    2. Let _scope_ be the LexicalEnvironment of the running execution context.
    3. Let _head_ be CoveredAsyncArrowHead of |CoverCallExpressionAndAsyncArrowHead|.
    4. Let _parameters_ be the |ArrowFormalParameters| production matched by _head_.
    5. Let _closure_ be AsyncFunctionCreate("Arrow", _parameters_, |ConciseBody|, _scope_, _strict_).
    6. Return _closure_.
  </emu-alg>
</emu-clause>
